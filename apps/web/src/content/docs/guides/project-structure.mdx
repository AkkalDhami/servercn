---
title: Project Structure
description: Understand how ServerCN organizes your project files based on your chosen architecture.
---

# Project Structure

ServerCN adapts to your project's architecture. When you initialize ServerCN, you choose between **MVC** and **Feature-based** architectures. Components are then installed following the structure that matches your choice.

## Overview

ServerCN supports two main architectural patterns:

- **MVC Architecture**: Traditional Model-View-Controller structure with layer-based organization
- **Feature-based Architecture**: Feature-module structure with shared utilities

Both architectures follow consistent patterns and conventions, making it easy to understand and maintain your codebase.

## Base Project Structure

Regardless of architecture, your project will have this base structure:

```
my-backend/
├── src/                    # Source directory (configurable)
├── servercn.json          # ServerCN configuration
├── package.json           # Node.js dependencies
├── tsconfig.json          # TypeScript configuration
├── .env                   # Environment variables (gitignored)
├── .env.example           # Environment variables template
└── README.md              # Project documentation
```

## MVC Architecture

MVC (Model-View-Controller) architecture organizes code by **layers** rather than features. This is ideal for smaller projects or teams familiar with traditional backend patterns.

### Directory Structure

```
src/
├── configs/               # Configuration files
│   └── env.ts            # Environment configuration
├── constants/             # Constants and enums
│   └── status-codes.ts   # HTTP status codes
├── controllers/           # Route controllers
│   └── user.controller.ts
├── middlewares/           # Express middlewares
│   ├── error-handler.ts
│   ├── auth.ts
│   └── validate-request.ts
├── models/                # Database models
│   └── user.model.ts
├── routes/                # Route definitions
│   ├── index.ts          # Main route index
│   └── user.routes.ts
├── services/              # Business logic
│   └── user.service.ts
├── types/                 # TypeScript type definitions
│   └── user.ts
├── utils/                 # Utility functions
│   ├── api-error.ts
│   ├── api-response.ts
│   ├── logger.ts
│   └── jwt.ts
├── validations/           # Validation schemas
│   └── user.validation.ts
└── app.ts                 # Express app entry point
```

### Directory Purposes

#### `configs/`

Configuration files for your application:

```ts
// src/configs/env.ts
interface Config {
  PORT: number;
  NODE_ENV: string;
  DATABASE_URL: string;
}

const env: Config = {
  PORT: Number(process.env.PORT) || 3000,
  NODE_ENV: process.env.NODE_ENV || "development",
  DATABASE_URL: process.env.DATABASE_URL!,
};

export default env;
```

<br />

#### `constants/`


Application-wide constants:

```ts
// src/constants/status-codes.ts
export const STATUS_CODES = {
  OK: 200,
  CREATED: 201,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  NOT_FOUND: 404,
  INTERNAL_SERVER_ERROR: 500,
} as const;
```

<br />

#### `controllers/`

Route handlers that process requests and return responses:

```ts
// src/controllers/user.controller.ts
import { Request, Response } from "express";
import { UserService } from "../services/user.service";

export const getUser = async (req: Request, res: Response) => {
  const user = await UserService.findById(req.params.id);
  return res.json({ success: true, data: user });
};
```
<br />

#### `middlewares/`

Express middleware functions:

```ts
// src/middlewares/auth.ts
import { Request, Response, NextFunction } from "express";
import { verifyToken } from "../utils/jwt";

export const authenticate = (
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  const token = req.headers.authorization;
  const user = verifyToken(token);
  req.user = user;
  next();
};
```

<br />

#### `models/`

Database models and schemas:

```ts
// src/models/user.model.ts
import mongoose, { Schema, Model } from "mongoose";

interface IUser {
  name: string;
  email: string;
  password: string;
}

const userSchema = new Schema<IUser>({
  name: { type: String, required: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
});

export const User: Model<IUser> = mongoose.model("User", userSchema);
```
<br />

#### `routes/`

Route definitions that map URLs to controllers:

```ts
// src/routes/user.routes.ts
import { Router } from "express";
import { getUser, createUser } from "../controllers/user.controller";
import { authenticate } from "../middlewares/auth";

const router = Router();

router.get("/:id", authenticate, getUser);
router.post("/", createUser);

export default router;
```
<br />

#### `services/`

Business logic layer:

```ts
// src/services/user.service.ts
import { User } from "../models/user.model";

export class UserService {
  static async findById(id: string) {
    return await User.findById(id);
  }

  static async create(data: any) {
    return await User.create(data);
  }
}
```
<br />

#### `utils/`

Reusable utility functions:

```ts
// src/utils/api-error.ts
export class ApiError extends Error {
  constructor(
    public statusCode: number,
    message: string,
  ) {
    super(message);
  }
}
```
<br />

#### `validations/`

Request validation schemas:

```ts
// src/validations/user.validation.ts
import { z } from "zod";

export const createUserSchema = z.object({
  body: z.object({
    name: z.string().min(2),
    email: z.string().email(),
  }),
});
```

### MVC Example: Complete User Module

```
src/
├── controllers/
│   └── user.controller.ts      # Handles HTTP requests
├── services/
│   └── user.service.ts        # Business logic
├── models/
│   └── user.model.ts          # Database model
├── routes/
│   └── user.routes.ts         # Route definitions
├── validations/
│   └── user.validation.ts    # Validation schemas
└── types/
    └── user.ts                # TypeScript types
```

## Feature-Based Architecture

Feature-based architecture organizes code by **features** or **modules**. Each feature is self-contained with its own controllers, services, models, and routes. Shared code lives in a `shared/` directory.

### Directory Structure

```
src/
├── shared/                   # Shared code across features
│   ├── configs/
│   │   └── env.ts
│   ├── constants/
│   │   └── status-codes.ts
│   ├── errors/
│   │   └── api-error.ts
│   ├── middlewares/
│   │   ├── error-handler.ts
│   │   ├── auth.ts
│   │   └── validate-request.ts
│   └── utils/
│       ├── api-response.ts
│       ├── logger.ts
│       └── jwt.ts
├── modules/                  # Feature modules
│   ├── user/
│   │   ├── controllers/
│   │   │   └── user.controller.ts
│   │   ├── services/
│   │   │   └── user.service.ts
│   │   ├── models/
│   │   │   └── user.model.ts
│   │   ├── routes/
│   │   │   └── user.routes.ts
│   │   ├── validations/
│   │   │   └── user.validation.ts
│   │   └── types/
│   │       └── user.ts
│   └── auth/
│       ├── controllers/
│       ├── services/
│       ├── routes/
│       └── validations/
├── routes/                   # Main route index
│   └── index.ts
└── app.ts                    # Express app entry point
```

### Directory Purposes

#### `shared/`

Code shared across all features:

- **`shared/configs/`**: Application configuration
- **`shared/constants/`**: Shared constants
- **`shared/errors/`**: Error classes and handlers
- **`shared/middlewares/`**: Global middlewares
- **`shared/utils/`**: Shared utility functions

<br />

#### `modules/`

Self-contained feature modules. Each module contains:

- **`controllers/`**: Feature-specific controllers
- **`services/`**: Feature-specific business logic
- **`models/`**: Feature-specific database models
- **`routes/`**: Feature-specific routes
- **`validations/`**: Feature-specific validation schemas
- **`types/`**: Feature-specific TypeScript types

<br />

#### `routes/index.ts`

Main route aggregator:

```ts
// src/routes/index.ts
import { Router } from "express";
import UserRouter from "../modules/user/routes/user.routes";
import AuthRouter from "../modules/auth/routes/auth.routes";

const router = Router();

router.use("/v1/users", UserRouter);
router.use("/v1/auth", AuthRouter);

export default router;
```

### Feature-Based Example: User Module

```
src/
├── shared/
│   ├── middlewares/
│   │   └── auth.ts              # Shared auth middleware
│   └── utils/
│       └── api-error.ts         # Shared error class
└── modules/
    └── user/                     # User feature module
        ├── controllers/
        │   └── user.controller.ts
        ├── services/
        │   └── user.service.ts
        ├── models/
        │   └── user.model.ts
        ├── routes/
        │   └── user.routes.ts
        ├── validations/
        │   └── user.validation.ts
        └── types/
            └── user.ts
```

## Component Placement

When you add a ServerCN component, it's placed according to your architecture:

### MVC Architecture

| Component Type | Location                  |
| -------------- | ------------------------- |
| Middlewares    | `src/middlewares/`        |
| Utilities      | `src/utils/`              |
| Constants      | `src/constants/`          |
| Errors         | `src/utils/` (as utility) |
| Validations    | `src/validations/`        |

### Feature-Based Architecture

| Component Type | Location                             |
| -------------- | ------------------------------------ |
| Middlewares    | `src/shared/middlewares/`            |
| Utilities      | `src/shared/utils/`                  |
| Constants      | `src/shared/constants/`              |
| Errors         | `src/shared/errors/`                 |
| Validations    | `src/modules/{feature}/validations/` |

## Choosing an Architecture

### Use MVC When:

- ✅ Building a small to medium-sized application
- ✅ Team is familiar with traditional backend patterns
- ✅ You want a simple, flat structure
- ✅ Features are tightly coupled
- ✅ You prefer layer-based organization

### Use Feature-Based When:

- ✅ Building a large application
- ✅ Features are independent and modular
- ✅ Multiple teams work on different features
- ✅ You want better code organization and scalability
- ✅ Features can be easily extracted or removed

## File Naming Conventions

ServerCN respects your naming convention preference:

### Kebab-Case (Recommended)

```
user-controller.ts
user-service.ts
user-model.ts
api-error.ts
```

### CamelCase

```
userController.ts
userService.ts
userModel.ts
apiError.ts
```

### Snake_Case

```
user_controller.ts
user_service.ts
user_model.ts
api_error.ts
```

### PascalCase

```
UserController.ts
UserService.ts
UserModel.ts
ApiError.ts
```

## Import Patterns

### MVC Architecture

```ts
// From controller
import { UserService } from "../services/user.service";
import { User } from "../models/user.model";
import { ApiError } from "../utils/api-error";

// From route
import { getUser } from "../controllers/user.controller";
import { authenticate } from "../middlewares/auth";
```

### Feature-Based Architecture

```ts
// From feature module
import { UserService } from "./services/user.service";
import { User } from "./models/user.model";

// From shared
import { ApiError } from "../../shared/errors/api-error";
import { authenticate } from "../../shared/middlewares/auth";
```

## Best Practices

### 1. Keep Features Independent

In feature-based architecture, each module should be self-contained:

```ts
// ✅ Good: Feature imports from shared
import { ApiError } from "../../shared/errors/api-error";

// ❌ Bad: Feature imports from another feature
import { UserService } from "../../user/services/user.service";
```

### 2. Use Shared for Common Code

Put reusable code in `shared/`:

- Error classes
- Common utilities
- Global middlewares
- Configuration

### 3. Consistent File Organization

Follow the same structure within each feature:

```
feature/
├── controllers/
├── services/
├── models/
├── routes/
├── validations/
└── types/
```

### 4. Clear Separation of Concerns

- **Controllers**: Handle HTTP requests/responses
- **Services**: Business logic
- **Models**: Database interactions
- **Routes**: URL mapping
- **Validations**: Request validation

### 5. Type Safety

Use TypeScript types consistently:

```ts
// src/types/user.ts
export interface User {
  id: string;
  name: string;
  email: string;
}
```

## Example: Complete Project Structure

### MVC Project

```
my-backend/
├── src/
│   ├── configs/
│   │   └── env.ts
│   ├── constants/
│   │   └── status-codes.ts
│   ├── controllers/
│   │   ├── user.controller.ts
│   │   └── auth.controller.ts
│   ├── middlewares/
│   │   ├── error-handler.ts
│   │   ├── auth.ts
│   │   └── validate-request.ts
│   ├── models/
│   │   └── user.model.ts
│   ├── routes/
│   │   ├── index.ts
│   │   ├── user.routes.ts
│   │   └── auth.routes.ts
│   ├── services/
│   │   ├── user.service.ts
│   │   └── auth.service.ts
│   ├── utils/
│   │   ├── api-error.ts
│   │   ├── api-response.ts
│   │   ├── jwt.ts
│   │   └── logger.ts
│   ├── validations/
│   │   ├── user.validation.ts
│   │   └── auth.validation.ts
│   └── app.ts
├── servercn.json
├── package.json
└── tsconfig.json
```

### Feature-Based Project

```
my-backend/
├── src/
│   ├── shared/
│   │   ├── configs/
│   │   │   └── env.ts
│   │   ├── constants/
│   │   │   └── status-codes.ts
│   │   ├── errors/
│   │   │   └── api-error.ts
│   │   ├── middlewares/
│   │   │   ├── error-handler.ts
│   │   │   ├── auth.ts
│   │   │   └── validate-request.ts
│   │   └── utils/
│   │       ├── api-response.ts
│   │       ├── jwt.ts
│   │       └── logger.ts
│   ├── modules/
│   │   ├── user/
│   │   │   ├── controllers/
│   │   │   │   └── user.controller.ts
│   │   │   ├── services/
│   │   │   │   └── user.service.ts
│   │   │   ├── models/
│   │   │   │   └── user.model.ts
│   │   │   ├── routes/
│   │   │   │   └── user.routes.ts
│   │   │   ├── validations/
│   │   │   │   └── user.validation.ts
│   │   │   └── types/
│   │   │       └── user.ts
│   │   └── auth/
│   │       ├── controllers/
│   │       ├── services/
│   │       ├── routes/
│   │       └── validations/
│   ├── routes/
│   │   └── index.ts
│   └── app.ts
├── servercn.json
├── package.json
└── tsconfig.json
```

## Migrating Between Architectures

If you need to switch architectures:

1. **Update `servercn.json`**:

   ```json
   {
     "stack": {
       "architecture": "feature" // Change from "mvc"
     }
   }
   ```

2. **Reorganize existing code** manually or use a migration script

3. **New components** will follow the updated architecture

> **Note**: Existing components won't automatically move. You'll need to reorganize them manually or reinstall components.

## Configuration

Your architecture choice is stored in `servercn.json`:

```json
{
  "stack": {
    "architecture": "mvc" // or "feature"
  },
  "project": {
    "srcDir": "src" // Customizable source directory
  }
}
```

You can change the architecture at any time by editing this file. New components will use the updated architecture.
