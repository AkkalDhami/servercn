---
title: Auth Domain Schemas
description: Complete authentication system schemas including User, OTP, and Session models for building secure authentication workflows.
command: npx servercn add schema auth

mvc_structure:
  - type: folder
    name: src
    children:
      - type: folder
        name: drizzle
        children:
          - type: folder
            name: schemas
            children:
              - type: file
                name: otp.schema.ts
                content: |
                  import {
                    mysqlTable,
                    serial,
                    varchar,
                    boolean,
                    timestamp,
                    int,
                    mysqlEnum,
                    index
                  } from "drizzle-orm/mysql-core";
                  import { timestamps } from "./schema.helper";

                  const OTP_MAX_ATTEMPTS = 5;

                  const OTP_TYPES = [
                    "signin",
                    "email-verification",
                    "password-reset",
                    "password-change"
                  ] as const;

                  export const otps = mysqlTable(
                    "otps",
                    {
                      id: serial("id").primaryKey(),
                      email: varchar("email", { length: 255 }).notNull(),
                      otpHashCode: varchar("otp_hash_code", { length: 255 }).notNull(),
                      nextResendAllowedAt: timestamp("next_resend_allowed_at", {
                        mode: "date"
                      }).notNull(),
                      type: mysqlEnum("type", OTP_TYPES).notNull(),
                      expiresAt: timestamp("expires_at", { mode: "date" }).notNull(),
                      isUsed: boolean("is_used").default(false).notNull(),
                      usedAt: timestamp("used_at", { mode: "date" }),
                      attempts: int("attempts").default(0).notNull(),
                      maxAttempts: int("max_attempts").default(OTP_MAX_ATTEMPTS).notNull(),
                      ...timestamps
                    },
                    table => [
                      index("email_type_idx").on(table.email, table.type),
                      index("expires_at_idx").on(table.expiresAt),
                      index("is_used_idx").on(table.isUsed)
                    ]
                  );

                  export type Otp = typeof otps.$inferSelect;
                  export type NewOtp = typeof otps.$inferInsert;

              - type: file
                name: refresh-token.schema.ts
                content: |
                  import {
                    mysqlTable,
                    serial,
                    varchar,
                    boolean,
                    timestamp,
                    index,
                    bigint,
                    text
                  } from "drizzle-orm/mysql-core";
                  import { relations } from "drizzle-orm";
                  import { users } from "./user.schema";
                  import { timestamps } from "./schema.helper";

                  export const refreshTokens = mysqlTable(
                    "refresh_tokens",
                    {
                      id: serial("id").primaryKey(),
                      userId: bigint("user_id", { mode: "number", unsigned: true })
                        .references(() => users.id, { onDelete: "cascade" })
                        .notNull(),
                      tokenHash: text("token_hash").notNull(),
                      expiresAt: timestamp("expires_at").notNull(),
                      isRevoked: boolean("is_revoked").default(false).notNull(),
                      revokedAt: timestamp("revoked_at"),
                      replacedByTokenHash: varchar("replaced_by_token_hash", { length: 255 }),
                      ...timestamps
                    },
                    table => [
                      index("user_id_idx").on(table.userId),
                      index("token_hash_idx").on(table.tokenHash),
                      index("is_revoked_idx").on(table.isRevoked),
                      index("expires_at_idx").on(table.expiresAt)
                    ]
                  );

                  //? Relations between user and refresh tokens. Many refresh tokens can be associated with one user. (Many-to-One)
                  export const refreshTokensRelations = relations(refreshTokens, ({ one }) => {
                    return {
                      user: one(users, {
                        fields: [refreshTokens.userId],
                        references: [users.id]
                      })
                    };
                  });

                  //? Refresh Token type
                  export type RefreshToken = typeof refreshTokens.$inferSelect;
                  export type NewRefreshToken = typeof refreshTokens.$inferInsert;

              - type: file
                name: schema.helper.ts
                content: |
                  import { timestamp } from "drizzle-orm/mysql-core";

                  export const timestamps = {
                    createdAt: timestamp("created_at").defaultNow().notNull(),
                    updatedAt: timestamp("updated_at").defaultNow().onUpdateNow().notNull()
                  };

              - type: file
                name: session.schema.ts
                content: |
                  import {
                    mysqlTable,
                    serial,
                    varchar,
                    timestamp,
                    boolean,
                    index,
                    int
                  } from "drizzle-orm/mysql-core";
                  import { relations } from "drizzle-orm";
                  import { users } from "./user.schema";
                  import { timestamps } from "./schema.helper";

                  export const sessions = mysqlTable(
                    "sessions",
                    {
                      id: serial("id").primaryKey(),
                      userId: int("user_id")
                        .references(() => users.id, { onDelete: "cascade" })
                        .notNull(),
                      tokenHash: varchar("token_hash", { length: 255 }).notNull().unique(),
                      ip: varchar("ip", { length: 45 }),
                      userAgent: varchar("user_agent", { length: 255 }),
                      isActive: boolean("is_active").default(true).notNull(),
                      lastUsedAt: timestamp("last_used_at").defaultNow().notNull(),
                      expiresAt: timestamp("expires_at").notNull(),
                      ...timestamps
                    },
                    table => [
                      index("userId_idx").on(table.userId),
                      index("tokenHash_idx").on(table.tokenHash),
                      index("isActive_idx").on(table.isActive),
                      index("userId_isActive_idx").on(table.userId, table.isActive),
                      index("userId_lastUsedAt_idx").on(table.userId, table.lastUsedAt)
                    ]
                  );

                  //? Relations between user and sessions. One user can have many sessions. (One-to-Many)
                  export const sessionsRelations = relations(sessions, ({ one }) => ({
                    user: one(users, {
                      fields: [sessions.userId],
                      references: [users.id]
                    })
                  }));

                  export type Session = typeof sessions.$inferSelect;
                  export type NewSession = typeof sessions.$inferInsert;

              - type: file
                name: user.schema.ts
                content: |
                  import {
                    mysqlTable,
                    serial,
                    varchar,
                    boolean,
                    timestamp,
                    int,
                    json,
                    uniqueIndex,
                    index,
                    mysqlEnum
                  } from "drizzle-orm/mysql-core";
                  import { timestamps } from "./schema.helper";
                  import { relations } from "drizzle-orm";
                  import { refreshTokens } from "./refresh-token.schema";

                  export interface IAvatar {
                    public_id?: string;
                    url: string;
                    size?: number;
                  }

                  export const users = mysqlTable(
                    "users",
                    {
                      id: serial("id").primaryKey(),
                      name: varchar("name", { length: 100 }).notNull(),
                      email: varchar("email", { length: 255 }).notNull().unique(),
                      password: varchar("password", { length: 255 }),
                      role: mysqlEnum("role", ["user", "admin"]).default("user").notNull(),

                      provider: mysqlEnum("provider", ["local", "google", "github"])
                        .default("local")
                        .notNull(),
                      providerId: varchar("provider_id", { length: 255 }),

                      avatar: json("avatar").$type<IAvatar>(),

                      isEmailVerified: boolean("is_email_verified").default(false).notNull(),
                      lastLoginAt: timestamp("last_login_at"),
                      failedLoginAttempts: int("failed_login_attempts").default(0).notNull(),
                      lockUntil: timestamp("lock_until"),

                      isDeleted: boolean("is_deleted").default(false).notNull(),
                      deletedAt: timestamp("deleted_at"),
                      reActivateAvailableAt: timestamp("re_activate_available_at"),

                      ...timestamps
                    },
                    table => [
                      uniqueIndex("email_idx").on(table.email),
                      index("role_idx").on(table.role),
                      index("is_deleted_idx").on(table.isDeleted)
                    ]
                  );

                  //? Relations between user and refresh tokens. One user can have many refresh tokens. (One-to-Many)
                  export const usersRelations = relations(users, ({ many }) => ({
                    refreshTokens: many(refreshTokens)
                  }));

                  //? User type
                  export type User = typeof users.$inferSelect;
                  export type NewUser = typeof users.$inferInsert;

      - type: file
        name: index.ts
        content: |
          export * from "./user.schema";
          export * from "./refresh-token.schema";
          export * from "./otp.schema";
          export * from "./session.schema";

  - type: file
    name: drizzle.config.ts
    content: |
      import { Config, defineConfig } from "drizzle-kit";

      export default defineConfig({
        out: "./src/drizzle/migrations",
        schema: "./src/drizzle/index.ts",
        dialect: "mysql",
        dbCredentials: {
          url: process.env.DATABASE_URL!
        },
        verbose: true,
        strict: true
      }) satisfies Config;

feature_structure:
  - type: folder
    name: src
    children:
      - type: folder
        name: drizzle
        children:
          - type: folder
            name: schemas
            children:
              - type: file
                name: otp.schema.ts
                content: |
                  import {
                    mysqlTable,
                    serial,
                    varchar,
                    boolean,
                    timestamp,
                    int,
                    mysqlEnum,
                    index
                  } from "drizzle-orm/mysql-core";
                  import { timestamps } from "./schema.helper";

                  const OTP_MAX_ATTEMPTS = 5;

                  const OTP_TYPES = [
                    "signin",
                    "email-verification",
                    "password-reset",
                    "password-change"
                  ] as const;

                  export const otps = mysqlTable(
                    "otps",
                    {
                      id: serial("id").primaryKey(),
                      email: varchar("email", { length: 255 }).notNull(),
                      otpHashCode: varchar("otp_hash_code", { length: 255 }).notNull(),
                      nextResendAllowedAt: timestamp("next_resend_allowed_at", {
                        mode: "date"
                      }).notNull(),
                      type: mysqlEnum("type", OTP_TYPES).notNull(),
                      expiresAt: timestamp("expires_at", { mode: "date" }).notNull(),
                      isUsed: boolean("is_used").default(false).notNull(),
                      usedAt: timestamp("used_at", { mode: "date" }),
                      attempts: int("attempts").default(0).notNull(),
                      maxAttempts: int("max_attempts").default(OTP_MAX_ATTEMPTS).notNull(),
                      ...timestamps
                    },
                    table => [
                      index("email_type_idx").on(table.email, table.type),
                      index("expires_at_idx").on(table.expiresAt),
                      index("is_used_idx").on(table.isUsed)
                    ]
                  );

                  export type Otp = typeof otps.$inferSelect;
                  export type NewOtp = typeof otps.$inferInsert;

              - type: file
                name: refresh-token.schema.ts
                content: |
                  import {
                    mysqlTable,
                    serial,
                    varchar,
                    boolean,
                    timestamp,
                    index,
                    bigint,
                    text
                  } from "drizzle-orm/mysql-core";
                  import { relations } from "drizzle-orm";
                  import { users } from "./user.schema";
                  import { timestamps } from "./schema.helper";

                  export const refreshTokens = mysqlTable(
                    "refresh_tokens",
                    {
                      id: serial("id").primaryKey(),
                      userId: bigint("user_id", { mode: "number", unsigned: true })
                        .references(() => users.id, { onDelete: "cascade" })
                        .notNull(),
                      tokenHash: text("token_hash").notNull(),
                      expiresAt: timestamp("expires_at").notNull(),
                      isRevoked: boolean("is_revoked").default(false).notNull(),
                      revokedAt: timestamp("revoked_at"),
                      replacedByTokenHash: varchar("replaced_by_token_hash", { length: 255 }),
                      ...timestamps
                    },
                    table => [
                      index("user_id_idx").on(table.userId),
                      index("token_hash_idx").on(table.tokenHash),
                      index("is_revoked_idx").on(table.isRevoked),
                      index("expires_at_idx").on(table.expiresAt)
                    ]
                  );

                  //? Relations between user and refresh tokens. Many refresh tokens can be associated with one user. (Many-to-One)
                  export const refreshTokensRelations = relations(refreshTokens, ({ one }) => {
                    return {
                      user: one(users, {
                        fields: [refreshTokens.userId],
                        references: [users.id]
                      })
                    };
                  });

                  //? Refresh Token type
                  export type RefreshToken = typeof refreshTokens.$inferSelect;
                  export type NewRefreshToken = typeof refreshTokens.$inferInsert;

              - type: file
                name: schema.helper.ts
                content: |
                  import { timestamp } from "drizzle-orm/mysql-core";

                  export const timestamps = {
                    createdAt: timestamp("created_at").defaultNow().notNull(),
                    updatedAt: timestamp("updated_at").defaultNow().onUpdateNow().notNull()
                  };

              - type: file
                name: session.schema.ts
                content: |
                  import {
                    mysqlTable,
                    serial,
                    varchar,
                    timestamp,
                    boolean,
                    index,
                    int
                  } from "drizzle-orm/mysql-core";
                  import { relations } from "drizzle-orm";
                  import { users } from "./user.schema";
                  import { timestamps } from "./schema.helper";

                  export const sessions = mysqlTable(
                    "sessions",
                    {
                      id: serial("id").primaryKey(),
                      userId: int("user_id")
                        .references(() => users.id, { onDelete: "cascade" })
                        .notNull(),
                      tokenHash: varchar("token_hash", { length: 255 }).notNull().unique(),
                      ip: varchar("ip", { length: 45 }),
                      userAgent: varchar("user_agent", { length: 255 }),
                      isActive: boolean("is_active").default(true).notNull(),
                      lastUsedAt: timestamp("last_used_at").defaultNow().notNull(),
                      expiresAt: timestamp("expires_at").notNull(),
                      ...timestamps
                    },
                    table => [
                      index("userId_idx").on(table.userId),
                      index("tokenHash_idx").on(table.tokenHash),
                      index("isActive_idx").on(table.isActive),
                      index("userId_isActive_idx").on(table.userId, table.isActive),
                      index("userId_lastUsedAt_idx").on(table.userId, table.lastUsedAt)
                    ]
                  );

                  //? Relations between user and sessions. One user can have many sessions. (One-to-Many)
                  export const sessionsRelations = relations(sessions, ({ one }) => ({
                    user: one(users, {
                      fields: [sessions.userId],
                      references: [users.id]
                    })
                  }));

                  export type Session = typeof sessions.$inferSelect;
                  export type NewSession = typeof sessions.$inferInsert;

              - type: file
                name: user.schema.ts
                content: |
                  import {
                    mysqlTable,
                    serial,
                    varchar,
                    boolean,
                    timestamp,
                    int,
                    json,
                    uniqueIndex,
                    index,
                    mysqlEnum
                  } from "drizzle-orm/mysql-core";
                  import { timestamps } from "./schema.helper";
                  import { relations } from "drizzle-orm";
                  import { refreshTokens } from "./refresh-token.schema";

                  export interface IAvatar {
                    public_id?: string;
                    url: string;
                    size?: number;
                  }

                  export const users = mysqlTable(
                    "users",
                    {
                      id: serial("id").primaryKey(),
                      name: varchar("name", { length: 100 }).notNull(),
                      email: varchar("email", { length: 255 }).notNull().unique(),
                      password: varchar("password", { length: 255 }),
                      role: mysqlEnum("role", ["user", "admin"]).default("user").notNull(),

                      provider: mysqlEnum("provider", ["local", "google", "github"])
                        .default("local")
                        .notNull(),
                      providerId: varchar("provider_id", { length: 255 }),

                      avatar: json("avatar").$type<IAvatar>(),

                      isEmailVerified: boolean("is_email_verified").default(false).notNull(),
                      lastLoginAt: timestamp("last_login_at"),
                      failedLoginAttempts: int("failed_login_attempts").default(0).notNull(),
                      lockUntil: timestamp("lock_until"),

                      isDeleted: boolean("is_deleted").default(false).notNull(),
                      deletedAt: timestamp("deleted_at"),
                      reActivateAvailableAt: timestamp("re_activate_available_at"),

                      ...timestamps
                    },
                    table => [
                      uniqueIndex("email_idx").on(table.email),
                      index("role_idx").on(table.role),
                      index("is_deleted_idx").on(table.isDeleted)
                    ]
                  );

                  //? Relations between user and refresh tokens. One user can have many refresh tokens. (One-to-Many)
                  export const usersRelations = relations(users, ({ many }) => ({
                    refreshTokens: many(refreshTokens)
                  }));

                  //? User type
                  export type User = typeof users.$inferSelect;
                  export type NewUser = typeof users.$inferInsert;

      - type: file
        name: index.ts
        content: |
          export * from "./user.schema";
          export * from "./refresh-token.schema";
          export * from "./otp.schema";
          export * from "./session.schema";

  - type: file
    name: drizzle.config.ts
    content: |
      import { Config, defineConfig } from "drizzle-kit";

      export default defineConfig({
        out: "./src/drizzle/migrations",
        schema: "./src/drizzle/index.ts",
        dialect: "mysql",
        dbCredentials: {
          url: process.env.DATABASE_URL!
        },
        verbose: true,
        strict: true
      }) satisfies Config;
---

# Auth Domain Schemas

The **Auth Domain** provides a complete set of production-ready schemas for building secure authentication systems in your Node.js applications.

This domain includes three core schemas that work together to handle user authentication, verification, and session management.

## Database Variants

The Auth Domain is available for multiple databases:

1. **[MongoDB (Mongoose)](/docs/schemas/auth-mongodb)** - Using Mongoose models and TTL indexes.
2. **[PostgreSQL (Drizzle)](/docs/schemas/auth-postgresql)** - Type-safe Drizzle schemas for PostgreSQL.
3. **[MySQL (Drizzle)](/docs/schemas/auth-mysql)** - Type-safe Drizzle schemas for MySQL.

Together, these schemas provide everything you need to build:

- Email/password authentication
- Email verification flows
- Password reset functionality
- Two-factor authentication (2FA)
- Session management
- OAuth integration (Google, GitHub, etc.)

## Quick Start

### Install All Auth Schemas

To install all auth-related schemas at once, run:

<PackageManagerTabs command="npx servercn add schema auth" />

This will install:

- <Code children="User" /> schema (auth/user)
- <Code children="OTP" /> schema (auth/otp)
- <Code children="Session" /> schema (auth/session)
- <Code children="Refresh Token" /> schema (auth/refresh-token)
- <Code children="Auth Constants" /> (OTP types, max attempts, etc.)

### Install Individual Schemas

You can also install schemas individually:

**User Schema:**

<PackageManagerTabs command="npx servercn add schema auth/user" />

**OTP Schema:**

<PackageManagerTabs command="npx servercn add schema auth/otp" />

**Session Schema:**

<PackageManagerTabs command="npx servercn add schema auth/session" />

**Refresh Token Schema:**

<PackageManagerTabs command="npx servercn add schema auth/refresh-token" />

## Schemas Breakdown

### 1. User Schema

The **User Schema** is the foundation of your authentication system. It stores user identity, credentials, and profile information.

**Key Features:**

- Email/password authentication
- OAuth provider support (Google, GitHub)
- Role-based access control (user, admin)
- Email verification status
- Account locking for security
- Soft delete functionality
- Avatar/profile management

**View Documentation: [MongoDB](/docs/schemas/auth-mongodb) | [PostgreSQL](/docs/schemas/auth-postgresql) | [MySQL](/docs/schemas/auth-mysql)**

**Quick Example:**

```ts
import User from "@/models/user";

// Create a new user
const user = await User.create({
  name: "John Doe",
  email: "john@example.com",
  password: hashedPassword,
  role: "user",
  isEmailVerified: false
});
```

### 2. OTP Schema

The **OTP Schema** handles one-time password verification for various authentication workflows.

**Key Features:**

- Multiple OTP types (signin, email-verification, password-reset, password-change)
- Cryptographic hashing for security
- Auto-expiration with TTL indexes
- Rate limiting (max attempts)
- Resend cooldown protection
- User and email references

**View Documentation: [MongoDB](/docs/schemas/auth-mongodb) | [PostgreSQL](/docs/schemas/auth-postgresql) | [MySQL](/docs/schemas/auth-mysql)**

**Quick Example:**

```ts
import Otp from "@/models/otp";
import { generateOTP } from "@/helpers/token.helpers";

// Generate and store OTP
const { code, hashCode, expiresAt } = generateOTP(6, 5); // 6 digits, 5 min TTL

await Otp.create({
  userId: user._id,
  email: user.email,
  otpHashCode: hashCode,
  type: "email-verification",
  expiresAt,
  nextResendAllowedAt: new Date(Date.now() + 60 * 1000) // 1 minute
});

// Send OTP via email (never store plain code)
await sendEmail(user.email, `Your verification code: ${code}`);
```

### 3. Session Schema

The **Session Schema** manages user sessions for authenticated users, supporting both stateful and stateless authentication.

**Key Features:**

- Secure token hashing
- Session expiration
- Device tracking (user agent, IP)
- Active/inactive status
- Session revocation
- Multi-device support

**View Documentation: [MongoDB](/docs/schemas/auth-mongodb) | [PostgreSQL](/docs/schemas/auth-postgresql) | [MySQL](/docs/schemas/auth-mysql)**

**Quick Example:**

```ts
import Session from "@/models/session";
import { generateSecureToken } from "@/helpers/token.helpers";

// Create a session
const token = generateSecureToken(32);
const hashedToken = crypto.createHash("sha256").update(token).digest("hex");

await Session.create({
  userId: user._id,
  tokenHash: hashedToken,
  userAgent: req.headers["user-agent"],
  ipAddress: req.ip,
  expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
});

// Return token to client (only shown once)
res.cookie("session_token", token, { httpOnly: true, secure: true });
```

### 4. Refresh Token Schema

The **Refresh Token Schema** manages long-lived tokens used to renew access tokens in JWT-based authentication systems.

**Key Features:**

- Secure token hashing
- Token rotation support (theft detection)
- Family revocation
- Auto-expiration

**View Documentation: [MongoDB](/docs/schemas/auth-mongodb) | [PostgreSQL](/docs/schemas/auth-postgresql) | [MySQL](/docs/schemas/auth-mysql)**

**Quick Example:**

```ts
import RefreshToken from "@/models/refresh-token";
import { generateSecureToken } from "@/helpers/token.helpers";

// Create a refresh token
const token = generateSecureToken(40);
const hashedToken = crypto.createHash("sha256").update(token).digest("hex");

await RefreshToken.create({
  userId: user._id,
  tokenHash: hashedToken,
  expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days
});
```

## Database Support

All auth schemas support multiple databases:

- **MongoDB** - via Mongoose
- **MySQL** - via Drizzle ORM
- **PostgreSQL** - via Drizzle ORM

The CLI automatically detects your database configuration from <Code children="servercn.config.json" /> and generates the appropriate schema.

## Security Best Practices

### Password Security

- Always hash passwords before storing (use [Password Hashing](/docs/components/password-hashing))
- Never return password field in queries (`select: false`)
- Implement account locking after failed attempts

### OTP Security

- Hash OTPs before storing (SHA-256)
- Set appropriate expiration times (5-15 minutes)
- Implement rate limiting (max 5 attempts)
- Add resend cooldown (1 minute)
- Never log OTP values

### Session Security

- Hash session tokens before storing
- Set reasonable expiration times
- Track device and IP information
- Implement session revocation
- Use secure, httpOnly cookies
- Rotate tokens on sensitive actions

### General Security

- Use HTTPS in production
- Implement CSRF protection
- Add rate limiting on auth endpoints
- Log authentication events
- Notify users of suspicious activity

## Related Components

These components work well with the Auth Domain schemas:

- **[Password Hashing](/docs/components/password-hashing)** - Secure password hashing with argon2/bcrypt
- **[Generate OTP/Token](/docs/components/generate-otp-token)** - Cryptographic token generation
- **[JWT Utils](/docs/components/jwt-utils)** - JWT token generation and verification
- **[Email Service](/docs/components/email-service)** - Send verification emails
- **[Rate Limiter](/docs/components/rate-limiter)** - Protect auth endpoints
- **[RBAC](/docs/components/rbac)** - Role-based access control

## Learn More

- [MongoDB (Mongoose) Schemas](/docs/schemas/auth-mongodb)
- [PostgreSQL (Drizzle) Schemas](/docs/schemas/auth-postgresql)
- [MySQL (Drizzle) Schemas](/docs/schemas/auth-mysql)
- [Password Hashing Component](/docs/components/password-hashing)
- [Generate OTP/Token Component](/docs/components/generate-otp-token)
