---
title: Auth | OTP | Schema
description: The Auth OTP schema handles one-time password verification for email verification, password resets, and two-factor authentication.
command: npx servercn add schema auth/otp

mvc_structure:
  - type: folder
    name: src
    children:
      - type: folder
        name: constants
        children:
          - type: file
            name: auth.ts
            content: |
              export const OTP_MAX_ATTEMPTS = 5;
              export const OTP_CODE_LENGTH = 6 as const;
              export const OTP_EXPIRES_IN = 5 * 60 * 1000 as const; // 5 minutes

              export const OTP_TYPES = [
                "signin",
                "email-verification",
                "password-reset",
                "password-change",
              ] as const;

              export type OTPTypes = typeof OTP_TYPES[number];

      - type: folder
        name: models
        children:
          - type: file
            name: otp.model.ts
            content: |
              import mongoose, { Document, Model, Schema } from "mongoose";
              import { OTP_MAX_ATTEMPTS, OTP_TYPES, OTP_CODE_LENGTH } from "../constants/auth";

              //? otp interface
              export interface IOtp extends Document {
                _id: mongoose.Types.ObjectId;
                email: string;
                otpHashCode: string;
                contextToken: string;
                nextResendAllowedAt: Date;
                type: OTPTypes;
                expiresAt: Date;
                isUsed: boolean;
                usedAt?: Date;
                attempts: number;
                maxAttempts: number;
                createdAt: Date;
                updatedAt: Date;
              }

              //? otp schema
              const otpSchema = new Schema<IOtp>(
                {
                  email: {
                    type: String,
                    required: [true, "Email is required"],
                    lowercase: true,
                    trim: true
                  },
                  otpHashCode: {
                    type: String,
                    required: [true, "OTP hash code is required"],
                    select: false // Never return OTP hash code in queries by default
                  },
                  nextResendAllowedAt: {
                    type: Date,
                    required: [true, "Next resend allowed at is required"],
                  },
                  type: {
                    type: String,
                    enum: OTP_TYPES,
                    required: [true, "OTP type is required"]
                  },
                  expiresAt: {
                    type: Date,
                    required: [true, "Expiration time is required"]
                  },
                  isUsed: {
                    type: Boolean,
                    default: false
                  },
                  usedAt: {
                    type: Date
                  },
                  attempts: {
                    type: Number,
                    default: 0
                  },
                  maxAttempts: {
                    type: Number,
                    default: OTP_MAX_ATTEMPTS // Prevent brute force attacks
                  }
                },
                {
                  timestamps: true
                }
              );

              // Performance Indexes
              otpSchema.index({ email: 1, type: 1 }); // Quick lookup by email and type
              otpSchema.index({ expiresAt: 1 }); // TTL index for auto-cleanup
              otpSchema.index({ isUsed: 1 }); // Filter used vs unused OTPs
              otpSchema.index(
                { createdAt: 1 },
                { expireAfterSeconds: OTP_EXPIRES_IN / 1000 }
              ); // ttl index

              const Otp: Model<IOtp> = mongoose.models.Otp || mongoose.model<IOtp>("Otp", otpSchema);

              export default Otp;

feature_structure:
  - type: folder
    name: src
    children:
      - type: folder
        name: modules
        children:
          - type: folder
            name: auth
            children:
              - type: file
                name: otp.model.ts
                content: |
                  import mongoose, { Document, Model, Schema } from "mongoose";
                  import { OTPTypes, OTP_MAX_ATTEMPTS, OTP_TYPES } from "../../shared/constants/auth";

                  //? otp interface
                  export interface IOtp extends Document {
                    _id: mongoose.Types.ObjectId;
                    email: string;
                    otpHashCode: string;
                    contextToken: string;
                    nextResendAllowedAt: Date;
                    type: OTPTypes;
                    expiresAt: Date;
                    isUsed: boolean;
                    usedAt?: Date;
                    attempts: number;
                    maxAttempts: number;
                    createdAt: Date;
                    updatedAt: Date;
                  }

                  //? otp schema
                  const otpSchema = new Schema<IOtp>(
                    {
                      email: {
                        type: String,
                        required: [true, "Email is required"],
                        lowercase: true,
                        trim: true
                      },
                      otpHashCode: {
                        type: String,
                        required: [true, "OTP hash code is required"],
                        select: false // Never return OTP hash code in queries by default
                      },
                      nextResendAllowedAt: {
                        type: Date,
                        required: [true, "Next resend allowed at is required"],
                      },
                      type: {
                        type: String,
                        enum: OTP_TYPES,
                        required: [true, "OTP type is required"]
                      },
                      expiresAt: {
                        type: Date,
                        required: [true, "Expiration time is required"]
                      },
                      isUsed: {
                        type: Boolean,
                        default: false
                      },
                      usedAt: {
                        type: Date
                      },
                      attempts: {
                        type: Number,
                        default: 0
                      },
                      maxAttempts: {
                        type: Number,
                        default: OTP_MAX_ATTEMPTS // Prevent brute force attacks
                      }
                    },
                    {
                      timestamps: true
                    }
                  );

                  // Performance Indexes
                  otpSchema.index({ email: 1, type: 1 }); // Quick lookup by email and type
                  otpSchema.index({ expiresAt: 1 }); // TTL index for auto-cleanup
                  otpSchema.index({ isUsed: 1 }); // Filter used vs unused OTPs
                  otpSchema.index(
                    { createdAt: 1 },
                    { expireAfterSeconds: OTP_EXPIRES_IN / 1000 }
                  ); // ttl index

                  const Otp: Model<IOtp> = mongoose.models.Otp || mongoose.model<IOtp>("Otp", otpSchema);

                  export default Otp;

      - type: folder
        name: shared
        children:
          - type: folder
            name: constants
            children:
              - type: file
                name: auth.ts
                content: |
                  export const OTP_MAX_ATTEMPTS = 5;
                  export const OTP_CODE_LENGTH = 6 as const;
                  export const OTP_EXPIRES_IN = 5 * 60 * 1000 as const; // 5 minutes

                  export const OTP_TYPES = [
                    "signin",
                    "email-verification",
                    "password-reset",
                    "password-change",
                  ] as const;

                  export type OTPTypes = typeof OTP_TYPES[number];
---

# Auth OTP Schema

The **Auth OTP** model is a critical security component used for one-time password verification in servercn-based applications.

It handles email verification, password reset flows, and two-factor authentication (2FA) with built-in expiration, rate limiting, and security features.

This model is designed to provide **secure, time-limited verification codes** for various authentication workflows.

## Installation Guide

To add the Auth OTP schema to your project, run the following command:

<PackageManagerTabs command="npx servercn add schema auth/otp" />

## Schema Definition

### 1. Mongoose (MongoDB)

**MVC:** <Code children="src/models/otp.model.ts" />

**Feature:** <Code children="src/modules/auth/otp.model.ts" />

A production-grade schema featuring user references, attempt tracking, multiple OTP types, and comprehensive security features.

```ts
import mongoose, { Document, Model, Schema } from "mongoose";

//? auth constants, servercn config all the constants in constants/auth.ts

const OTP_MAX_ATTEMPTS = 5;

const OTP_TYPES = [
  "signin",
  "email-verification",
  "password-reset",
  "password-change"
] as const;

type OTPType = (typeof OTP_TYPES)[number];

//? otp interface
export interface IOtp extends Document {
  _id: mongoose.Types.ObjectId;
  email: string;
  otpHashCode: string;
  contextToken: string;
  nextResendAllowedAt: Date;
  type: OTPType;
  expiresAt: Date;
  isUsed: boolean;
  usedAt?: Date;
  attempts: number;
  maxAttempts: number;
  createdAt: Date;
  updatedAt: Date;
}

//? otp schema
const otpSchema = new Schema<IOtp>(
  {
    email: {
      type: String,
      required: [true, "Email is required"],
      lowercase: true,
      trim: true
    },
    otpHashCode: {
      type: String,
      required: [true, "OTP hash code is required"],
      select: false // Never return OTP hash code in queries by default
    },
    contextToken: {
      type: String,
      required: [true, "Context token is required"]
    },
    nextResendAllowedAt: {
      type: Date,
      required: [true, "Next resend allowed at is required"]
    },
    type: {
      type: String,
      enum: OTP_TYPES,
      required: [true, "OTP type is required"]
    },
    expiresAt: {
      type: Date,
      required: [true, "Expiration time is required"]
    },
    isUsed: {
      type: Boolean,
      default: false
    },
    usedAt: {
      type: Date
    },
    attempts: {
      type: Number,
      default: 0
    },
    maxAttempts: {
      type: Number,
      default: OTP_MAX_ATTEMPTS // Prevent brute force attacks
    }
  },
  {
    timestamps: true
  }
);

// Performance Indexes
otpSchema.index({ email: 1, type: 1 }); // Quick lookup by email and type
otpSchema.index({ expiresAt: 1 }); // TTL index for auto-cleanup
otpSchema.index({ isUsed: 1 }); // Filter used vs unused OTPs
otpSchema.index(
  { createdAt: 1 },
  { expireAfterSeconds: OTP_EXPIRES_IN / 1000 }
); // ttl index

const Otp: Model<IOtp> =
  mongoose.models.Otp || mongoose.model<IOtp>("Otp", otpSchema);

export default Otp;
```

### 2. Drizzle ORM (MySQL)

**MVC:** <Code children={'src/drizzle/schemas/otp.schema.ts'} />

**Feature:** <Code children={'src/drizzle/schemas/otp.schema.ts'} />

A production-ready Drizzle schema with user references, attempt tracking, and comprehensive security.

```ts
import {
  mysqlTable,
  serial,
  varchar,
  boolean,
  timestamp,
  int,
  mysqlEnum,
  index
} from "drizzle-orm/mysql-core";

const OTP_MAX_ATTEMPTS = 5;

const OTP_TYPES = [
  "signin",
  "email-verification",
  "password-reset",
  "password-change"
] as const;

type OTPType = (typeof OTP_TYPES)[number];

export const timestamps = {
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().onUpdateNow().notNull()
};

export const otps = mysqlTable(
  "otps",
  {
    id: serial("id").primaryKey(),
    email: varchar("email", { length: 255 }).notNull(),
    otpHashCode: varchar("otp_hash_code", { length: 255 }).notNull(),
    nextResendAllowedAt: timestamp("next_resend_allowed_at", {
      mode: "string"
    }).notNull(),
    type: mysqlEnum("type", OTP_TYPES).notNull(),
    expiresAt: timestamp("expires_at", { mode: "string" }).notNull(),
    isUsed: boolean("is_used").default(false).notNull(),
    usedAt: timestamp("used_at", { mode: "string" }),
    attempts: int("attempts").default(0).notNull(),
    maxAttempts: int("max_attempts").default(OTP_MAX_ATTEMPTS).notNull(),
    ...timestamps
  },
  table => [
    index("email_type_idx").on(table.email, table.type),
    index("expires_at_idx").on(table.expiresAt),
    index("is_used_idx").on(table.isUsed)
  ]
);

export type Otp = typeof otps.$inferSelect;
export type NewOtp = typeof otps.$inferInsert;
```

### 3. Drizzle ORM (PostgreSQL)

**MVC:** <Code children={'src/drizzle/schemas/otp.schema.ts'} />

**Feature:** <Code children={'src/drizzle/schemas/otp.schema.ts'} />

A production-ready Drizzle schema for PostgreSQL with full security features.

```ts
import {
  pgTable,
  serial,
  varchar,
  boolean,
  timestamp,
  integer,
  pgEnum,
  index
} from "drizzle-orm/pg-core";

const OTP_MAX_ATTEMPTS = 5;

const OTP_TYPES = [
  "signin",
  "email-verification",
  "password-reset",
  "password-change"
] as const;

type OTPType = (typeof OTP_TYPES)[number];

export const otpTypeEnum = pgEnum("otp_type", OTP_TYPES);

const timestamps = {
  createdAt: timestamp("created_at", { mode: "string" }).defaultNow().notNull(),
  updatedAt: timestamp("updated_at", { mode: "string" })
    .defaultNow()
    .$onUpdate(() => new Date().toISOString())
    .notNull()
};

export const otps = pgTable(
  "otps",
  {
    id: serial("id").primaryKey(),
    email: varchar("email", { length: 255 }).notNull(),
    otpHashCode: varchar("otp_hash_code", { length: 255 }).notNull(),
    nextResendAllowedAt: timestamp("next_resend_allowed_at", {
      mode: "string"
    }).notNull(),
    type: otpTypeEnum("type").notNull(),
    expiresAt: timestamp("expires_at", { mode: "string" }).notNull(),
    isUsed: boolean("is_used").default(false).notNull(),
    usedAt: timestamp("used_at", { mode: "string" }),
    attempts: integer("attempts").default(0).notNull(),
    maxAttempts: integer("max_attempts").default(OTP_MAX_ATTEMPTS).notNull(),
    ...timestamps
  },
  table => [
    index("email_type_idx").on(table.email, table.type),
    index("expires_at_idx").on(table.expiresAt),
    index("is_used_idx").on(table.isUsed)
  ]
);

export type Otp = typeof otps.$inferSelect;
export type NewOtp = typeof otps.$inferInsert;
```

## Key Features

- **Auto-Expiration**: MongoDB TTL index automatically deletes expired OTPs. For SQL databases, implement a cleanup job.
- **Security**: OTP field is excluded from default queries (`select: false` in Mongoose).
- **Rate Limiting**: Built-in attempt tracking prevents brute force attacks.
- **Multiple Use Cases**: Supports email verification, password reset, and two-factor authentication.
- **Type Safety**: Full TypeScript support with proper interfaces and type inference.
- **Optimized Indexes**: Composite indexes for fast lookups by user, email, and type.

## Best Practices

### 1. OTP Generation

Generate cryptographically secure random OTPs:

```ts
import crypto from "node:crypto";

export function generateOTP(length: number = 6, ttlMinutes: number = 5) {
  const code = crypto
    .randomInt(0, Math.pow(10, length))
    .toString()
    .padStart(length, "0");

  const hashCode = crypto
    .createHash("sha256")
    .update(String(code))
    .digest("hex");

  const expiresAt = new Date(Date.now() + ttlMinutes * 60 * 1000).toISOString();
  return { code, hashCode, expiresAt };
}
```

### 2. OTP Verification

Verify OTPs before using them:

```ts
import crypto from "node:crypto";

export function verifyOTP(plainOTP: string, otpHashCode: string): boolean {
  const validCode = crypto
    .createHash("sha256")
    .update(String(plainOTP))
    .digest("hex");
  return validCode === otpHashCode;
}
```

For more details, see [Generate OTP/Token](/docs/components/generate-otp-token) servercn component's docs.

### 3. Rate Limiting

Implement attempt tracking to prevent brute force:

```ts
async function verifyOTPWithRateLimit(otpId: string, userOTP: string) {
  const otpRecord = await Otp.findById(otpId).select("+otp");

  if (!otpRecord) {
    throw new Error("OTP not found");
  }

  // Check if max attempts exceeded
  if (otpRecord.attempts >= otpRecord.maxAttempts) {
    throw new Error("Maximum verification attempts exceeded");
  }

  // Check if expired
  if (new Date() > otpRecord.expiresAt) {
    throw new Error("OTP has expired");
  }

  // Check if already used
  if (otpRecord.isUsed) {
    throw new Error("OTP has already been used");
  }

  // Increment attempts
  otpRecord.attempts += 1;
  await otpRecord.save();

  // Verify OTP
  const isValid = await bcrypt.compare(userOTP, otpRecord.otp);

  if (!isValid) {
    throw new Error("Invalid OTP");
  }

  // Mark as used
  otpRecord.isUsed = true;
  otpRecord.usedAt = new Date();
  await otpRecord.save();

  return true;
}
```

### 5. Cleanup Strategy

For SQL databases (MySQL, PostgreSQL), implement a cleanup job:

```ts
// Run this periodically (e.g., every hour)
async function cleanupExpiredOTPs() {
  const now = new Date();

  // Delete expired OTPs
  await db.delete(otps).where(lt(otps.expiresAt, now));

  // Or delete used OTPs older than 24 hours
  const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
  await db
    .delete(otps)
    .where(and(eq(otps.isUsed, true), lt(otps.usedAt, oneDayAgo)));
}
```

### 6. Security Recommendations

- **Never log OTPs**: Don't include OTP values in logs or error messages.
- **Use HTTPS**: Always send OTPs over secure connections.
- **Email delivery**: Use a reliable email service with proper SPF/DKIM configuration.
- **One-time use**: Ensure OTPs can only be used once.
- **Invalidate on password change**: Delete all password reset OTPs when password is changed.
- **User notification**: Notify users when OTPs are generated for their account.

## Example Usage

### Creating an OTP

```ts
import Otp from "@/models/otp";
import bcrypt from "bcryptjs";

async function createOTP(email: string, type: string) {
  // Generate OTP
  const plainOTP = generateSecureOTP(6);

  // Hash it
  const hashedOTP = await bcrypt.hash(plainOTP, 10);

  // Create record
  const otp = await Otp.create({
    email,
    otp: hashedOTP,
    type,
    expiresAt: getExpirationTime(type),
    maxAttempts: 5
  });

  // Send email with plainOTP (never store it)
  await sendOTPEmail(email, plainOTP);

  return otp._id;
}
```

### Verifying an OTP

```ts
async function verifyOTP(otpId: string, userProvidedOTP: string) {
  const otpRecord = await Otp.findById(otpId).select("+otp");

  if (!otpRecord) {
    throw new Error("Invalid OTP");
  }

  // Check expiration
  if (new Date() > otpRecord.expiresAt) {
    throw new Error("OTP expired");
  }

  // Check if used
  if (otpRecord.isUsed) {
    throw new Error("OTP already used");
  }

  // Check attempts
  if (otpRecord.attempts >= otpRecord.maxAttempts) {
    throw new Error("Too many attempts");
  }

  // Increment attempts
  otpRecord.attempts += 1;
  await otpRecord.save();

  // Verify
  const isValid = await bcrypt.compare(userProvidedOTP, otpRecord.otp);

  if (!isValid) {
    throw new Error("Invalid OTP");
  }

  // Mark as used
  otpRecord.isUsed = true;
  otpRecord.usedAt = new Date();
  await otpRecord.save();

  return otpRecord;
}
```

## Related Schemas

- [User Schema](/docs/schemas/auth-user) - User authentication and profile management
- [Session Schema](/docs/schemas/auth-session) - Session management for authenticated users
