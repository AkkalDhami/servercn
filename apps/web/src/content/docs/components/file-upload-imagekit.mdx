---
title: File Upload (ImageKit)
description: The File Upload component provides a standardized way to handle file uploads in ServerCN using ImageKit as the storage provider.

command: npx servercn add file-upload-imagekit

mvc_structure:
  - type: folder
    name: src
    children:
      - type: folder
        name: configs
        children:
          - type: file
            name: env.ts
            content: |
              interface Config {
                PORT: number;
                NODE_ENV: string;
                LOG_LEVEL: string;

                IMAGEKIT_PRIVATE_KEY: string;
              }

              const env: Config = {
                PORT: Number(process.env.PORT) || 3000,
                NODE_ENV: process.env.NODE_ENV || 'development',
                LOG_LEVEL: process.env.LOG_LEVEL || 'info',

                IMAGEKIT_PRIVATE_KEY: process.env.IMAGEKIT_PRIVATE_KEY!
              };

              export default env;

          - type: file
            name: imagekit.ts
            content: |
              // ImageKit Configuration

              import ImageKit from '@imagekit/nodejs';
              import env from './env';

              const imagekitClient = new ImageKit({
                privateKey: env.IMAGEKIT_PRIVATE_KEY,
              });

              export default imagekitClient;

      - type: folder
        name: constants
        children:
          - type: file
            name: status-codes.ts
            content: |
              export const STATUS_CODES = {
                // 2xx Success
                OK: 200,
                CREATED: 201,
                ACCEPTED: 202,
                NO_CONTENT: 204,

                // 3xx Redirection
                MOVED_PERMANENTLY: 301,
                FOUND: 302,
                NOT_MODIFIED: 304,

                // 4xx Client Errors
                BAD_REQUEST: 400,
                UNAUTHORIZED: 401,
                FORBIDDEN: 403,
                NOT_FOUND: 404,
                CONFLICT: 409,
                UNPROCESSABLE_ENTITY: 422,
                TOO_MANY_REQUESTS: 429,

                // 5xx Server Errors
                INTERNAL_SERVER_ERROR: 500,
                NOT_IMPLEMENTED: 501,
                BAD_GATEWAY: 502,
                SERVICE_UNAVAILABLE: 503,
                GATEWAY_TIMEOUT: 504,
              } as const;

              export type StatusCode = (typeof STATUS_CODES)[keyof typeof STATUS_CODES];

      - type: folder
        name: controllers
        children:
          - type: file
            name: upload.controller.ts
            content: |
              import { Request, Response, NextFunction } from "express";

              import {
                ImageKitUploadResult,
                deleteFileFromImageKit,
                uploadToImageKit,
              } from "../services/upload.service";

              import { ApiError } from "../utils/api-error";
              import { ApiResponse } from "../utils/api-response";
              import { AsyncHandler } from "../utils/async-handler";

              export const uploadFile = AsyncHandler(async (req: Request, res: Response, next: NextFunction) => {
                if (!req.file) {
                  return next(ApiError.badRequest("File is required"));
                }

                const file = await uploadToImageKit(req.file.buffer, {
                  folder: "uploads/files",
                  fileName: req.file.originalname
                });

                return ApiResponse.created(res, "File uploaded successfully", file);
              });

              export const uploadMultipleFile = AsyncHandler(
                async (req: Request, res: Response, next: NextFunction) => {
                  const files = req.files as Express.Multer.File[];

                  if (!files || files.length === 0) {
                    return next(ApiError.badRequest("Files are required"));
                  }

                  const results: ImageKitUploadResult[] = await Promise.all(
                    files.map(async (file) => {
                      return await uploadToImageKit(file.buffer, {
                        folder: "uploads/images",
                        fileName: file.originalname
                      });
                    })
                  );

                  return ApiResponse.created(res, "Files uploaded successfully", results);
                }
              );

              export const deleteFile = AsyncHandler(async (req: Request, res: Response, next: NextFunction) => {
                const { fileIds }: { fileIds: string[] } = req.body;

                if (!fileIds || fileIds.length === 0) {
                  return next(ApiError.badRequest("File IDs are required"));
                }

                await deleteFileFromImageKit(fileIds);

                return ApiResponse.Success(res, "File deleted successfully", null, 200);
              });

      - type: folder
        name: middlewares
        children:
          - type: file
            name: error-handler.ts
            content: |
              import { Request, Response, NextFunction } from "express";
              import env from "../configs/env";

              import { ApiError } from "../utils/api-error";
              import { logger } from "../utils/logger";
              import { STATUS_CODES } from "../constants/status-codes";

              export const errorHandler = (
                err: Error,
                req: Request,
                res: Response,
                next: NextFunction
              ) => {
                let statusCode = 500;
                let message = "Internal server error";

                if (err instanceof ApiError) {
                  statusCode = err.statusCode;
                  message = err.message;
                }

                logger.error(
                  err,
                 `Error: ${message} | Status: ${statusCode} | Path: ${req.method} ${req.originalUrl}`
                );

                const response = {
                  success: false,
                  message,
                  ...(env.NODE_ENV === "development" && { stack: err.stack }),
                };

                res.status(statusCode).json(response);
              };

          - type: file
            name: upload-file.ts
            content: |
              // multer configuration

              import multer from "multer";

              export const ALLOWED_FILE_TYPES = [
                "image/jpeg",
                "image/png",
                "image/webp",

                "video/mp4",
                "video/mpeg",
                "video/quicktime",

                "application/pdf",
              ];

              export const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

              const storage = multer.memoryStorage();

              const fileFilter: multer.Options["fileFilter"] = (_req, file, cb) => {
                if (!ALLOWED_FILE_TYPES.includes(file.mimetype)) {
                  return cb(null, false);
                }
                cb(null, true);
              };

              const upload = multer({
                storage,
                limits: { fileSize: MAX_FILE_SIZE },
                fileFilter,
              });

              export default upload;

      - type: folder
        name: routes
        children:
          - type: file
            name: upload.routes.ts
            content: |
              import { Router } from "express";

              import upload from "../middlewares/upload-file";
              import {
                deleteFile,
                uploadFile,
                uploadMultipleFile,
              } from "../controllers/upload.controller";

              const router = Router();

              router.post("/file", upload.single("file"), uploadFile);
              router.post("/files", upload.array("files", 10), uploadMultipleFile);
              router.delete("/", deleteFile);

              export default router;

      - type: folder
        name: services
        children:
          - type: file
            name: upload.service.ts
            content: |
              import imagekitClient from "../configs/imagekit";
              import { toFile } from "@imagekit/nodejs";

              export interface UploadOptions {
                folder: string;
                fileName?: string;
              }

              export interface ImageKitUploadResult {
                url: string;
                fileId: string;
                size: number;
              }

              export const uploadToImageKit = async (
                buffer: Buffer,
                options: UploadOptions
              ): Promise<ImageKitUploadResult> => {
                try {
                  const fileName = options.fileName || `file-${Date.now()}`;
                  const file = await toFile(buffer, fileName);

                  const result = await imagekitClient.files.upload({
                    file: file,
                    fileName: fileName,
                    folder: options.folder || "uploads"
                  });

                  return {
                    url: result.url || "",
                    fileId: result.fileId || "",
                    size: result.size || 0
                  };
                } catch (error) {
                  throw error;
                }
              };

              export const deleteFileFromImageKit = async (
                fileIds: string[]
              ): Promise<void> => {
                try {
                  await Promise.all(
                    fileIds.map(fileId => imagekitClient.files.delete(fileId))
                  );
                } catch (error) {
                  throw error;
                }
              };

      - type: folder
        name: utils
        children:
          - type: file
            name: api-error.ts
            content: |
              import { STATUS_CODES, StatusCode } from "../constants/status-codes";

              export class ApiError extends Error {
              public readonly statusCode: StatusCode;
              public readonly isOperational: boolean;
              public readonly errors?: unknown;

              constructor(
                  statusCode: StatusCode,
                  message: string,
                  errors?: unknown,
                  isOperational = true
              ) {
                  super(message);
                  this.name = "ApiError";
                  this.statusCode = statusCode;
                  this.errors = errors;
                  this.isOperational = isOperational;

                  Error.captureStackTrace(this, this.constructor);
              }

              static badRequest(message = "Bad Request", errors?: unknown) {
                  return new ApiError(STATUS_CODES.BAD_REQUEST, message, errors);
              }

              static unauthorized(message = "Unauthorized") {
                  return new ApiError(STATUS_CODES.UNAUTHORIZED, message);
              }

              static forbidden(message = "Forbidden") {
                  return new ApiError(STATUS_CODES.FORBIDDEN, message);
              }

              static notFound(message = "Not Found") {
                  return new ApiError(STATUS_CODES.NOT_FOUND, message);
              }

              static conflict(message = "Conflict") {
                  return new ApiError(STATUS_CODES.CONFLICT, message);
              }

              static server(message = "Internal Server Error") {
                  return new ApiError(STATUS_CODES.INTERNAL_SERVER_ERROR, message);
              }
              }

              /*
              ? Usage:
              * throw new ApiError(404, "Not found");
              * throw ApiError.badRequest("Bad request");
              */

          - type: file
            name: api-response.ts
            content: |
              import { STATUS_CODES, StatusCode } from "../constants/status-codes";
              import type { Response } from "express";

              type ApiResponseParams<T> = {
                success: boolean;
                message: string;
                statusCode: StatusCode;
                data?: T | null;
                errors?: unknown;
              };

              export class ApiResponse<T = unknown> {
                public readonly success: boolean;
                public readonly message: string;
                public readonly statusCode: StatusCode;
                public readonly data?: T | null;
                public readonly errors?: unknown;

                constructor({
                  success,
                  message,
                  statusCode,
                  data = null,
                  errors,
                }: ApiResponseParams<T>) {
                  this.success = success;
                  this.message = message;
                  this.statusCode = statusCode;
                  this.data = data;
                  this.errors = errors;
                }

                send(res: Response): Response {
                  return res.status(this.statusCode).json({
                    success: this.success,
                    message: this.message,
                    statusCode: this.statusCode,
                    ...(this.data !== undefined && { data: this.data }),
                    ...(this.errors !== undefined && { errors: this.errors }),
                  });
                }

                static Success<T>(
                  res: Response,
                  message: string,
                  data?: T,
                  statusCode: StatusCode = 200
                ): Response {
                  return new ApiResponse<T>({
                    success: true,
                    message,
                    data,
                    statusCode,
                  }).send(res);
                }

                static ok<T>(res: Response, message = "OK", data?: T) {
                  return ApiResponse.Success(res, message, data, STATUS_CODES.OK);
                }

                static created<T>(res: Response, message = "Created", data?: T) {
                  return ApiResponse.Success(res, message, data, STATUS_CODES.CREATED);
                }
              }

              /*
              * Usage:
              * ApiResponse.ok(res, "OK", data);
              * ApiResponse.created(res, "Created", data);
              */

          - type: file
            name: async-handler.ts
            content: |
              import { Request, Response, NextFunction } from "express";

              export type AsyncRouteHandler = (
                req: Request,
                res: Response,
                next: NextFunction
              ) => Promise<unknown>;

              export function AsyncHandler(fn: AsyncRouteHandler) {
                return function (req: Request, res: Response, next: NextFunction) {
                  Promise.resolve(fn(req, res, next)).catch(next);
                };
              }

          - type: file
            name: logger.ts
            content: |
              import pino from "pino";
              import env from "../configs/env";

              const isProduction = env.NODE_ENV === "production";

              export const logger = pino({
                level: env.LOG_LEVEL || "info",

                base: {
                  pid: process.pid
                },

                timestamp: pino.stdTimeFunctions.isoTime,

                formatters: {
                  level(label) {
                    return { level: label };
                  }
                },

                redact: {
                  paths: [
                    "req.headers.authorization",
                    "req.headers.cookie",
                    "password",
                    "token",
                    "refreshToken"
                  ],
                  censor: "[REDACTED]"
                },

                ...(isProduction
                  ? {}
                  : {
                      transport: {
                        target: "pino-pretty",
                        options: {
                          colorize: true,
                          translateTime: "SYS:standard",
                          ignore: "pid,hostname"
                        }
                      }
                    })
              });

      - type: file
        name: app.ts
        content: |
          import express, { Application } from "express";
          import "dotenv/config";

          import { errorHandler } from "./middlewares/error-handler";
          import { logger } from "./utils/logger";

          import uploadRoutes from "./routes/upload.routes";
          import env from "./configs/env";

          const app: Application = express();

          const PORT = env.PORT;

          // middlewares
          app.use(express.urlencoded({ extended: true }));
          app.use(express.json());

          // routes
          app.use("/api/uploads", uploadRoutes);

          // Global error handler
          app.use(errorHandler);

          app.listen(PORT, () => {
            logger.info(`Server is running on http://localhost:${PORT}`);
          });

  - type: file
    name: .env.example
    content: |
      PORT="8000"
      NODE_ENV="development"
      LOG_LEVEL="info"

      # ImageKit Configuration
      IMAGEKIT_PRIVATE_KEY="your-imagekit-private-key"

  - type: file
    name: tsconfig.json
    content: |
      {
        "compilerOptions": {
          "target": "ES2021",
          "module": "es2022",
          "moduleResolution": "bundler",
          "strict": true,
          "esModuleInterop": true,
          "skipLibCheck": true,
          "outDir": "dist",
          "rootDir": "src"
        },
        "include": [ "src/**/*" ],
        "exclude": [ "node_modules" ]
      }

feature_structure:
  - type: folder
    name: src
    children:
      - type: folder
        name: shared
        children:
          - type: folder
            name: configs
            children:
              - type: file
                name: env.ts
                content: |
                  interface Config {
                    PORT: number;
                    NODE_ENV: string;
                    LOG_LEVEL: string;

                    IMAGEKIT_PRIVATE_KEY: string;
                  }

                  const env: Config = {
                    PORT: Number(process.env.PORT) || 3000,
                    NODE_ENV: process.env.NODE_ENV || 'development',
                    LOG_LEVEL: process.env.LOG_LEVEL || 'info',

                    IMAGEKIT_PRIVATE_KEY: process.env.IMAGEKIT_PRIVATE_KEY!,
                  };

                  export default env;

              - type: file
                name: imagekit.ts
                content: |
                  import ImageKit from '@imagekit/nodejs';
                  import env from './env';

                  const imagekitClient = new ImageKit({
                    privateKey: env.IMAGEKIT_PRIVATE_KEY,
                  });

                  export default imagekitClient;

          - type: folder
            name: constants
            children:
              - type: file
                name: status-codes.ts
                content: |
                  export const STATUS_CODES = {
                    // 2xx Success
                    OK: 200,
                    CREATED: 201,
                    ACCEPTED: 202,
                    NO_CONTENT: 204,

                    // 3xx Redirection
                    MOVED_PERMANENTLY: 301,
                    FOUND: 302,
                    NOT_MODIFIED: 304,

                    // 4xx Client Errors
                    BAD_REQUEST: 400,
                    UNAUTHORIZED: 401,
                    FORBIDDEN: 403,
                    NOT_FOUND: 404,
                    CONFLICT: 409,
                    UNPROCESSABLE_ENTITY: 422,
                    TOO_MANY_REQUESTS: 429,

                    // 5xx Server Errors
                    INTERNAL_SERVER_ERROR: 500,
                    NOT_IMPLEMENTED: 501,
                    BAD_GATEWAY: 502,
                    SERVICE_UNAVAILABLE: 503,
                    GATEWAY_TIMEOUT: 504,
                  } as const;

                  export type StatusCode = (typeof STATUS_CODES)[keyof typeof STATUS_CODES];

          - type: folder
            name: errors
            children:
              - type: file
                name: api-error.ts
                content: |

                  import { STATUS_CODES, StatusCode } from "../constants/status-codes";

                  export class ApiError extends Error {
                  public readonly statusCode: StatusCode;
                  public readonly isOperational: boolean;
                  public readonly errors?: unknown;

                  constructor(
                      statusCode: StatusCode,
                      message: string,
                      errors?: unknown,
                      isOperational = true
                  ) {
                      super(message);
                      this.name = "ApiError";
                      this.statusCode = statusCode;
                      this.errors = errors;
                      this.isOperational = isOperational;

                      Error.captureStackTrace(this, this.constructor);
                  }

                    static badRequest(message = "Bad Request", errors?: unknown) {
                        return new ApiError(STATUS_CODES.BAD_REQUEST, message, errors);
                    }

                    static unauthorized(message = "Unauthorized") {
                        return new ApiError(STATUS_CODES.UNAUTHORIZED, message);
                    }

                    static forbidden(message = "Forbidden") {
                        return new ApiError(STATUS_CODES.FORBIDDEN, message);
                    }

                    static notFound(message = "Not Found") {
                        return new ApiError(STATUS_CODES.NOT_FOUND, message);
                    }

                    static conflict(message = "Conflict") {
                        return new ApiError(STATUS_CODES.CONFLICT, message);
                    }

                    static server(message = "Internal Server Error") {
                        return new ApiError(STATUS_CODES.INTERNAL_SERVER_ERROR, message);
                    }
                  }

                  /*
                  ? Usage:
                  * throw new ApiError(404, "Not found");
                  * throw ApiError.badRequest("Bad request");
                  */

          - type: folder
            name: utils
            children:
              - type: file
                name: api-response.ts
                content: |
                  import { STATUS_CODES, StatusCode } from "../constants/status-codes";
                  import type { Response } from "express";

                  type ApiResponseParams<T> = {
                    success: boolean;
                    message: string;
                    statusCode: StatusCode;
                    data?: T | null;
                    errors?: unknown;
                  };

                  export class ApiResponse<T = unknown> {
                    public readonly success: boolean;
                    public readonly message: string;
                    public readonly statusCode: StatusCode;
                    public readonly data?: T | null;
                    public readonly errors?: unknown;

                    constructor({
                      success,
                      message,
                      statusCode,
                      data = null,
                      errors,
                    }: ApiResponseParams<T>) {
                      this.success = success;
                      this.message = message;
                      this.statusCode = statusCode;
                      this.data = data;
                      this.errors = errors;
                    }

                    send(res: Response): Response {
                      return res.status(this.statusCode).json({
                        success: this.success,
                        message: this.message,
                        statusCode: this.statusCode,
                        ...(this.data !== undefined && { data: this.data }),
                        ...(this.errors !== undefined && { errors: this.errors }),
                      });
                    }

                    static Success<T>(
                      res: Response,
                      message: string,
                      data?: T,
                      statusCode: StatusCode = 200
                    ): Response {
                      return new ApiResponse<T>({
                        success: true,
                        message,
                        data,
                        statusCode,
                      }).send(res);
                    }

                    static ok<T>(res: Response, message = "OK", data?: T) {
                      return ApiResponse.Success(res, message, data, STATUS_CODES.OK);
                    }

                    static created<T>(res: Response, message = "Created", data?: T) {
                      return ApiResponse.Success(res, message, data, STATUS_CODES.CREATED);
                    }
                  }

                  /*
                  * Usage:
                  * ApiResponse.ok(res, "OK", data);
                  * ApiResponse.created(res, "Created", data);
                  */

              - type: file
                name: async-handler.ts
                content: |
                  import { Request, Response, NextFunction } from "express";

                  export type AsyncRouteHandler = (
                    req: Request,
                    res: Response,
                    next: NextFunction
                  ) => Promise<unknown>;

                  export function AsyncHandler(fn: AsyncRouteHandler) {
                    return function (req: Request, res: Response, next: NextFunction) {
                      Promise.resolve(fn(req, res, next)).catch(next);
                    };
                  }

              - type: file
                name: logger.ts
                content: |
                  import pino from "pino";
                  import  env  from "../configs/env";

                  export const logger = pino({
                    level: env.LOG_LEVEL,
                    transport:
                      env.NODE_ENV !== "production"
                        ? {
                            target: "pino-pretty",
                            options: {
                              colorize: true,
                              translateTime: "yyyy-mm-dd HH:MM:ss",
                              ignore: "pid,hostname",
                            },
                          }
                        : undefined,
                  });

          - type: folder
            name: middlewares
            children:
              - type: file
                name: error-handler.ts
                content: |
                  import { Request, Response, NextFunction } from "express";
                  import env from "../configs/env";

                  import { ApiError } from "../errors/api-error";
                  import { logger } from "../utils/logger";
                  import { STATUS_CODES } from "../constants/status-codes";

                  export const errorHandler = (
                    err: Error,
                    req: Request,
                    res: Response,
                    next: NextFunction
                  ) => {
                    let statusCode = 500;
                    let message = "Internal server error";

                    if (err instanceof ApiError) {
                      statusCode = err.statusCode;
                      message = err.message;
                    }

                    logger.error(
                      err,
                      `Error: ${message} | Status: ${statusCode} | Path: ${req.method} ${req.originalUrl}`
                    );

                    const response = {
                      success: false,
                      message,
                      ...(env.NODE_ENV === "development" && { stack: err.stack }),
                    };

                    res.status(statusCode).json(response);
                  };

              - type: file
                name: upload-file.ts
                content: |
                  // multer configuration

                  import multer from "multer";

                  export const ALLOWED_FILE_TYPES = [
                    "image/jpeg",
                    "image/png",
                    "image/webp",

                    "video/mp4",
                    "video/mpeg",
                    "video/quicktime",

                    "application/pdf",
                  ];

                  export const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

                  const storage = multer.memoryStorage();

                  const fileFilter: multer.Options["fileFilter"] = (_req, file, cb) => {
                    if (!ALLOWED_FILE_TYPES.includes(file.mimetype)) {
                      return cb(null, false);
                    }
                    cb(null, true);
                  };

                  const upload = multer({
                    storage,
                    limits: { fileSize: MAX_FILE_SIZE },
                    fileFilter,
                  });

                  export default upload;

      - type: folder
        name: modules
        children:
          - type: folder
            name: upload
            children:
              - type: file
                name: upload.controller.ts
                content: |
                  import { NextFunction, Request, Response } from "express";

                  import { ApiResponse } from "../../shared/utils/api-response";
                  import { AsyncHandler } from "../../shared/utils/async-handler";
                  import { ApiError } from "../../shared/errors/api-error";
                  import {
                    deleteFileFromImageKit,
                    ImageKitUploadResult,
                    uploadToImageKit
                  } from "./upload.service";

                  export const uploadFile = AsyncHandler(
                    async (req: Request, res: Response, next: NextFunction) => {
                      if (!req.file) {
                        return next(ApiError.badRequest("File is required"));
                      }

                      const file = await uploadToImageKit(req.file.buffer, {
                        folder: "uploads/files",
                        fileName: req.file.originalname
                      });

                      return ApiResponse.created(res, "File uploaded successfully", file);
                    }
                  );

                  export const uploadMultipleFile = AsyncHandler(
                    async (req: Request, res: Response, next: NextFunction) => {
                      const files = req.files as Express.Multer.File[];

                      if (!files || files.length === 0) {
                        return next(ApiError.badRequest("Files are required"));
                      }

                      const results: ImageKitUploadResult[] = await Promise.all(
                        files.map(async file => {
                          return await uploadToImageKit(file.buffer, {
                            folder: "uploads/images",
                            fileName: file.originalname
                          });
                        })
                      );

                      return ApiResponse.created(res, "Files uploaded successfully", results);
                    }
                  );

                  export const deleteFile = AsyncHandler(
                    async (req: Request, res: Response, next: NextFunction) => {
                      const { fileIds }: { fileIds: string[] } = req.body;

                      if (!fileIds || fileIds.length === 0) {
                        return next(ApiError.badRequest("File IDs are required"));
                      }

                      await deleteFileFromImageKit(fileIds);

                      return ApiResponse.Success(res, "File deleted successfully", null, 200);
                    }
                  );


              - type: file
                name: upload.routes.ts
                content: |
                  import { Router } from "express";

                  import upload from "../../shared/middlewares/upload-file";
                  import {
                    deleteFile,
                    uploadFile,
                    uploadMultipleFile,
                  } from "./upload.controller";

                  const router = Router();

                  router.post("/file", upload.single("file"), uploadFile);
                  router.post("/files", upload.array("files", 10), uploadMultipleFile);
                  router.delete("/", deleteFile);

                  export default router;

              - type: file
                name: upload.service.ts
                content: |
                  import imagekitClient from "../../shared/configs/imagekit";
                  import { toFile } from "@imagekit/nodejs";

                  export interface UploadOptions {
                    folder: string;
                    fileName?: string;
                  }

                  export interface ImageKitUploadResult {
                    url: string;
                    fileId: string;
                    size: number;
                  }

                  export const uploadToImageKit = async (
                    buffer: Buffer,
                    options: UploadOptions
                  ): Promise<ImageKitUploadResult> => {
                    try {
                      const fileName = options.fileName || `file-${Date.now()}`;
                      const file = await toFile(buffer, fileName);

                      const result = await imagekitClient.files.upload({
                        file: file,
                        fileName: fileName,
                        folder: options.folder || "uploads"
                      });

                      // console.log({ result });

                      return {
                        url: result.url || "",
                        fileId: result.fileId || "",
                        size: result.size || 0
                      };
                    } catch (error) {
                      throw error;
                    }
                  };

                  export const deleteFileFromImageKit = async (
                    fileIds: string[]
                  ): Promise<void> => {
                    try {
                      await Promise.all(
                        fileIds.map(fileId => imagekitClient.files.delete(fileId))
                      );
                    } catch (error) {
                      throw error;
                    }
                  };

      - type: folder
        name: routes
        children:
          - type: file
            name: index.ts
            content: |
              import { Router } from "express";
              import UploadRouter from "../modules/upload/upload.routes";

              const router = Router();

              router.use("/v1/uploads", UploadRouter);

              export default router;

      - type: file
        name: app.ts
        content: |
          import express, { type Application } from "express";
          import "dotenv/config";

          import { errorHandler } from './shared/middlewares/error-handler';
          import { logger } from "./shared/utils/logger";

          import Routes from "./routes/index";
          import env from "./shared/configs/env";

          const app: Application = express();

          const PORT = env.PORT;

          // middlewares
          app.use(express.urlencoded({ extended: true }));
          app.use(express.json());

          // routes here
          app.use("/api", Routes);

          // Global error handler (should be after routes)
          app.use(errorHandler);

          app.listen(PORT, () => {
            logger.info(`Server is running on http://localhost:${PORT}`);
          });

  - type: file
    name: .env.example
    content: |
      PORT="8000"
      NODE_ENV="development"
      LOG_LEVEL="info"

      # ImageKit Configuration
      IMAGEKIT_PRIVATE_KEY="your-imagekit-private-key"

  - type: file
    name: tsconfig.json
    content: |
      {
        "compilerOptions": {
          "target": "ES2021",
          "module": "es2022",
          "moduleResolution": "bundler",
          "strict": true,
          "esModuleInterop": true,
          "skipLibCheck": true,
          "outDir": "dist",
          "rootDir": "src"
        },
        "include": [ "src/**/*" ],
        "exclude": [ "node_modules" ]
      }
---

# File Upload (ImageKit)

The **File Upload** component provides a standardized way to handle file uploads in ServerCN using **ImageKit** as the storage provider.

It abstracts common concerns such as multipart handling, ImageKit configuration, and secure uploads, while integrating cleanly with the rest of the ServerCN backend utilities.

[Official ImageKit Documentation](https://imagekit.io/), [ImageKit Node.js SDK](https://github.com/imagekit-developer/imagekit-nodejs)

## Features

- ImageKit-backed file storage
- Supports images, videos, and raw files
- Secure server-side uploads
- Express-compatible middleware
- Works seamlessly with <Code children='ApiError' />, <Code children='AsyncHandler' />, and middleware

## Installation Guide

This component requires additional ServerCN components.

**_ðŸ‘‰ Note:_** _You do not need to install any servercn dependencies manually. Installing this component will automatically install all required servercn dependencies. Manual installation is optional if you prefer to manage dependencies yourself._

### 1. Install ServerCN dependencies(Optional)

- **HTTP Status Codes:**

<PackageManagerTabs command="npx servercn add http-status-codes" />

Documentation:
[HTTP Status Codes](/docs/components/http-status-codes)

- **Api Response Handler:**

<PackageManagerTabs command="npx servercn add response-formatter" />

Documentation:
[Api Response Handler](/docs/components/response-formatter)

- **Api Error Handler:**

<PackageManagerTabs command="npx servercn add error-handler" />

Documentation:
[Api Error Handler](/docs/components/error-handler)

- **Logger:**

<PackageManagerTabs command="npx servercn add logger-pino" />

Documentation:
[Logger](/docs/components/logger)

- **Async Handler:**

<PackageManagerTabs command="npx servercn add async-handler" />

Documentation:
[Async Handler](/docs/components/async-handler)

- **Global Error Handler:**

<PackageManagerTabs command="npx servercn add global-error-handler" />

Documentation:
[Global Error Handler](/docs/components/global-error-handler)

### 2. Install this component

<PackageManagerTabs command="npx servercn add file-upload-imagekit" />

## Prerequisites

You must have an ImageKit account. Click [here](https://imagekit.io) if you don't have one.

Define the following environment variables:

```bash
PORT="8000"
NODE_ENV="development"
LOG_LEVEL="info"

# ImageKit Configuration
IMAGEKIT_PRIVATE_KEY="your-imagekit-private-key"
```

Ensure the following configuration is defined:

**MVC:** <Code children="src/configs/env.ts" />

**Feature:** <Code children="src/shared/configs/env.ts" />

```ts
interface Config {
  PORT: number;
  NODE_ENV: string;
  LOG_LEVEL: string;

  IMAGEKIT_PRIVATE_KEY: string;
}

const env: Config = {
  PORT: Number(process.env.PORT) || 3000,
  NODE_ENV: process.env.NODE_ENV || "development",
  LOG_LEVEL: process.env.LOG_LEVEL || "info",

  IMAGEKIT_PRIVATE_KEY: process.env.IMAGEKIT_PRIVATE_KEY!
};

export default env;
```

## Basic Implementation

### 1. ImageKit Configuration

Create an ImageKit configuration file:

**MVC:** <Code children="src/configs/imagekit.ts" />

**Feature:** <Code children="src/shared/configs/imagekit.ts" />

```ts
import ImageKit from '@imagekit/nodejs';
import env from './env';

const imagekitClient = new ImageKit({
  privateKey: env.IMAGEKIT_PRIVATE_KEY,
});

export default imagekitClient;
```

### 2. Upload Middleware

ServerCN uses **multer** to handle multipart file uploads.

**MVC:** <Code children="src/middlewares/upload-file.ts" />

**Feature:** <Code children="src/shared/middlewares/upload-file.ts" />

```ts
import multer from "multer";

export const ALLOWED_FILE_TYPES = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "video/mp4",
  "video/mpeg",
  "video/quicktime",
  "application/pdf"
];

export const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

const storage = multer.memoryStorage();

const fileFilter: multer.Options["fileFilter"] = (_req, file, cb) => {
  if (!ALLOWED_FILE_TYPES.includes(file.mimetype)) {
    return cb(null, false);
  }
  cb(null, true);
};

const upload = multer({
  storage,
  limits: { fileSize: MAX_FILE_SIZE },
  fileFilter
});

export default upload;
```

### 3. ImageKit Services

Services for uploading files to ImageKit and deleting files from ImageKit.

**MVC:** <Code children="src/services/upload.service.ts" /> or

<Code children="src/utils/imagekit.ts" /> or
<Code children="src/helpers/imagekit.ts" />

**Feature:** <Code children="src/modules/upload/upload.service.ts" />

```ts
import imagekitClient from "../configs/imagekit";
import { toFile } from "@imagekit/nodejs";

export interface UploadOptions {
  folder: string;
  fileName?: string;
}

export interface ImageKitUploadResult {
  url: string;
  fileId: string;
  size: number;
}

export const uploadToImageKit = async (
  buffer: Buffer,
  options: UploadOptions
): Promise<ImageKitUploadResult> => {
  try {
    const fileName = options.fileName || `file-${Date.now()}`;
    const file = await toFile(buffer, fileName);

    const result = await imagekitClient.files.upload({
      file: file,
      fileName: fileName,
      folder: options.folder || "uploads"
    });

    return {
      url: result.url || "",
      fileId: result.fileId || "",
      size: result.size || 0
    };
  } catch (error) {
    throw error;
  }
};

export const deleteFileFromImageKit = async (
  fileIds: string[]
): Promise<void> => {
  try {
    await Promise.all(
      fileIds.map(fileId => imagekitClient.files.delete(fileId))
    );
  } catch (error) {
    throw error;
  }
};
```

## Usage Example

### 1. Setup controllers

**MVC:** <Code children="src/controllers/upload.controller.ts" />

```ts
import { Request, Response, NextFunction } from "express";

import {
  ImageKitUploadResult,
  deleteFileFromImageKit,
  uploadToImageKit
} from "../services/upload.service";

import { ApiError } from "../utils/api-error";
import { ApiResponse } from "../utils/api-response";
import { AsyncHandler } from "../utils/async-handler";

export const uploadFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    if (!req.file) {
      return next(ApiError.badRequest("File is required"));
    }

    const file = await uploadToImageKit(req.file.buffer, {
      folder: "uploads/files",
      fileName: req.file.originalname
    });

    return ApiResponse.created(res, "File uploaded successfully", file);
  }
);

export const uploadMultipleFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const files = req.files as Express.Multer.File[];

    if (!files || files.length === 0) {
      return next(ApiError.badRequest("Files are required"));
    }

    const results: ImageKitUploadResult[] = await Promise.all(
      files.map(async file => {
        return await uploadToImageKit(file.buffer, {
          folder: "uploads/images",
          fileName: file.originalname
        });
      })
    );

    return ApiResponse.created(res, "Files uploaded successfully", results);
  }
);

export const deleteFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const { fileIds }: { fileIds: string[] } = req.body;

    if (!fileIds || fileIds.length === 0) {
      return next(ApiError.badRequest("File IDs are required"));
    }

    await deleteFileFromImageKit(fileIds);

    return ApiResponse.Success(res, "File deleted successfully", null, 200);
  }
);
```

**Feature:** <Code children="src/modules/upload/upload.controller.ts" />

```ts
import { NextFunction, Request, Response } from "express";

import { ApiResponse } from "../../shared/utils/api-response";
import { AsyncHandler } from "../../shared/utils/async-handler";
import {
  CloudinaryUploadResult,
  deleteFileFromCloudinary,
  uploadToCloudinary
} from "./upload.service";
import { ApiError } from "../../shared/errors/api-error";

export const uploadFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    if (!req.file) {
      return next(ApiError.badRequest("File is required"));
    }

    const file = await uploadToImageKit(req.file.buffer, {
      folder: "uploads/files",
      fileName: req.file.originalname
    });

    return ApiResponse.created(res, "File uploaded successfully", file);
  }
);

export const uploadMultipleFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const files = req.files as Express.Multer.File[];

    if (!files || files.length === 0) {
      return next(ApiError.badRequest("Files are required"));
    }

    const results: ImageKitUploadResult[] = await Promise.all(
      files.map(async file => {
        return await uploadToImageKit(file.buffer, {
          folder: "uploads/images",
          fileName: file.originalname
        });
      })
    );

    return ApiResponse.created(res, "Files uploaded successfully", results);
  }
);

export const deleteFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const { fileIds }: { fileIds: string[] } = req.body;

    if (!fileIds || fileIds.length === 0) {
      return next(ApiError.badRequest("File IDs are required"));
    }

    await deleteFileFromImageKit(fileIds);

    return ApiResponse.Success(res, "File deleted successfully", null, 200);
  }
);
```

### 2. Setup routes

**MVC:** <Code children="src/routes/upload.routes.ts" />

```ts
import { Router } from "express";

import upload from "../middlewares/upload-file";
import {
  deleteFile,
  uploadFile,
  uploadMultipleFile
} from "../controllers/upload.controller";

const router = Router();

router.post("/file", upload.single("file"), uploadFile);
router.post("/files", upload.array("files", 10), uploadMultipleFile);
router.delete("/", deleteFile);

export default router;
```

**Feature:** <Code children="src/modules/upload/upload.routes.ts" />

```ts
import { Router } from "express";

import upload from "../../shared/middlewares/upload-file";
import {
  deleteFile,
  uploadFile,
  uploadMultipleFile
} from "./upload.controller";

const router = Router();

router.post("/file", upload.single("file"), uploadFile);
router.post("/files", upload.array("files", 10), uploadMultipleFile);
router.delete("/", deleteFile);

export default router;
```

<br />
<Code children="src/app.ts" />

```ts
import express, { Application } from "express";
import "dotenv/config";

import { errorHandler } from "./middlewares/error-handler";
import { logger } from "./utils/logger";

import uploadRoutes from "./routes/upload.routes";
import env from "./configs/env";

const app: Application = express();

const PORT = env.PORT;

// middlewares
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// routes
app.use("/api/uploads", uploadRoutes);

// Global error handler
app.use(errorHandler);

app.listen(PORT, () => {
  logger.info(`Server is running on http://localhost:${PORT}`);
});
```

## Security Best Practices

- Enforce file size limits
- Validate MIME types when required
- Use private folders for sensitive uploads
- Never expose ImageKit private keys to the client
- Prefer authenticated routes for uploads
- Use environment variables for all sensitive configuration
