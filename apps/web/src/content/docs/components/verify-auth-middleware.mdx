---
title: Verify Authentication Middleware
description: Express middleware to verify user authentication using access and refresh tokens.
command: npx servercn add verify-auth-middleware

mvc_structure:
  - type: folder
    name: src
    children:
      - type: folder
        name: configs
        children:
          - type: file
            name: env.ts
            content: |
              interface Config {
                PORT: number;
                NODE_ENV: string;
                LOG_LEVEL: string;
                JWT_ACCESS_SECRET: string;
                JWT_REFRESH_SECRET: string;
              }

              const env: Config = {
                PORT: Number(process.env.PORT) || 3000,
                NODE_ENV: process.env.NODE_ENV || 'development',
                LOG_LEVEL: process.env.LOG_LEVEL || 'info',
                JWT_REFRESH_SECRET: process.env.JWT_REFRESH_SECRET!,
                JWT_ACCESS_SECRET: process.env.JWT_ACCESS_SECRET!
              };

              export default env;

      - type: folder
        name: constants
        children:
          - type: file
            name: status-codes.ts
            content: |
              export const STATUS_CODES = {
                // 2xx Success
                OK: 200,
                CREATED: 201,
                ACCEPTED: 202,
                NO_CONTENT: 204,

                // 3xx Redirection
                MOVED_PERMANENTLY: 301,
                FOUND: 302,
                NOT_MODIFIED: 304,

                // 4xx Client Errors
                BAD_REQUEST: 400,
                UNAUTHORIZED: 401,
                FORBIDDEN: 403,
                NOT_FOUND: 404,
                CONFLICT: 409,
                UNPROCESSABLE_ENTITY: 422,
                TOO_MANY_REQUESTS: 429,

                // 5xx Server Errors
                INTERNAL_SERVER_ERROR: 500,
                NOT_IMPLEMENTED: 501,
                BAD_GATEWAY: 502,
                SERVICE_UNAVAILABLE: 503,
                GATEWAY_TIMEOUT: 504,
              } as const;

              export type StatusCode = (typeof STATUS_CODES)[keyof typeof STATUS_CODES];

      - type: folder
        name: middlewares
        children:
          - type: file
            name: error-handler.ts
            content: |
              import { Request, Response, NextFunction } from "express";
              import env from "../configs/env";

              import { ApiError } from "../utils/api-error";
              import { logger } from "../utils/logger";

              export const errorHandler = (
                err: Error,
                req: Request,
                res: Response,
                next: NextFunction
              ) => {
                let statusCode = 500;
                let message = "Internal server error";

                if (err instanceof ApiError) {
                  statusCode = err.statusCode;
                  message = err.message;
                }

                logger.error(
                 `Error: ${message} | Status: ${statusCode} | Path: ${req.method} ${req.originalUrl}`,
                  err
                );

                const response = {
                  success: false,
                  message,
                  ...(env.NODE_ENV === "development" && { stack: err.stack }),
                };

                res.status(statusCode).json(response);
              };

          - type: file
            name: verify-auth.ts
            content: |
              import { NextFunction, Request, Response } from "express";
              import {
                generateAccessToken,
                generateRefreshToken,
                verifyAccessToken,
                verifyRefreshToken,
              } from "../utils/jwt";
              import { UserRequest } from "../types/user";
              import { ApiError  } from "../utils/api-error";
              import { logger } from "../utils/logger";
              import User from "../models/user.model";
              import env from "../configs/env";

              const isProduction = env.NODE_ENV === "production";
              const ACCESS_TOKEN_EXPIRY = 15 * 60 * 1000;
              const REFRESH_TOKEN_EXPIRY = 7 * 24 * 60 * 60 * 1000;

              export const COOKIE_OPTIONS = {
                httpOnly: true,
                secure: isProduction,
                sameSite: isProduction ? ("none" as const) : ("lax" as const),
                path: "/",
              }

              export async function verifyAuthentication(
                req: UserRequest,
                res: Response,
                next: NextFunction,
              ): Promise<void> {

                const accessToken = req.cookies?.accessToken;
                const refreshToken = req.cookies?.refreshToken;

                // Step 1: Try validating access token
                
                try {
                  if (accessToken) {
                    const decoded = verifyAccessToken(accessToken);
                    req.user = decoded;
                    return next();
                  }
                } catch (err) {
                  // Access token expired or invalid
                  logger.warn("Access token verification failed");
                  return next(ApiError.badRequest("Invalid or expired access token"));
                }

                // Step 2: Refresh token required if access token fails
                
                if (!refreshToken) {
                  return next(ApiError.unauthorized("Unauthorized, Please login first."));
                }

                try {
                  const decodedRefresh = verifyRefreshToken(refreshToken);

                  // Step 3: Ensure user still exists
                
                  const userInDb = await User.findOne({
                    _id: decodedRefresh.userId,
                  });

                  if (!userInDb) {
                    return next(ApiError.unauthorized("Unauthorized, Please login first."));
                  }

                  // Step 4: Issue new tokens
                
                  const newAccessToken = generateAccessToken({
                    _id: userInDb._id.toString(),
                  });

                  const newRefreshToken = generateRefreshToken(
                    decodedRefresh.userId
                  );

                  // Step 5: Saved accessToken and refreshToken in cookie
                  res.cookie("accessToken", newAccessToken, {
                    ...COOKIE_OPTIONS,
                    maxAge: ACCESS_TOKEN_EXPIRY,
                  });

                  res.cookie("refreshToken", newRefreshToken, {
                    ...COOKIE_OPTIONS,
                    maxAge: REFRESH_TOKEN_EXPIRY,
                  });

                  // Step 6: Attach user to request
                  
                  req.user = {
                    _id: decodedRefresh.userId,
                  };

                  // you can update the refresh token in the database here if you store it in the database
                  return next();
                } catch (err: any) {
                  logger.warn("Refresh token verification failed");
                  return next(
                    ApiError.unauthorized("Unauthorized, Please login first.")
                  );
                }
              }

      - type: folder
        name: models
        children:
          - type: file
            name: user.model.ts
            content: |
              import mongoose, { Document, Model, Schema } from "mongoose";

              export interface IUser extends Document {
                _id: mongoose.Types.ObjectId;
                name: string;
                email: string;
                password: string;
                role: "user" | "admin";
                isEmailVerified: boolean;

                createdAt: Date;
                updatedAt: Date;
              }

              const userSchema = new Schema<IUser>(
                {
                  name: {
                    type: String,
                    required: [true, "Name is required"],
                    trim: true,
                  },
                  email: {
                    type: String,
                    required: [true, "Email is required"],
                    unique: true,
                    lowercase: true,
                    trim: true,
                  },
                  password: {
                    type: String,
                    select: false,
                    default: null,
                  },
                  role: {
                    type: String,
                    enum: ["user", "admin"],
                    default: "user",
                  },
                  isEmailVerified: {
                    type: Boolean,
                    default: false,
                  },
                },
                {
                  timestamps: true,
                }
              );

              const User: Model<IUser> = mongoose.model<IUser>("User", userSchema);
              export default User;

      - type: folder
        name: routes
        children:
          - type: file
            name: user.routes.ts
            content: |
              import { Response, Router } from "express";
              import { verifyAuthentication } from "../middlewares/verify-auth";
              import { UserRequest } from "../types/user";
              import { ApiResponse } from "../utils/api-response";

              const router = Router();

              router.get(
                "/profile",
                verifyAuthentication ,
                (req:UserRequest, res:Response) => {
                  return ApiResponse.ok(res, "User profile", req.user);
                }
              );

              export default router;

      - type: folder
        name: types
        children:
          - type: file
            name: user.ts
            content: |
              import { Request } from "express";
              import mongoose from "mongoose";

              export interface UserRequest extends Request {
                user?: {
                  _id?: string | mongoose.Types.ObjectId;
                };
              }

      - type: folder
        name: utils
        children:
          - type: file
            name: api-error.ts
            content: |
              import { STATUS_CODES, StatusCode } from "../constants/status-codes";

              export class ApiError extends Error {
              public readonly statusCode: StatusCode;
              public readonly isOperational: boolean;
              public readonly errors?: unknown;

              constructor(
                  statusCode: StatusCode,
                  message: string,
                  errors?: unknown,
                  isOperational = true
              ) {
                  super(message);
                  this.name = "ApiError";
                  this.statusCode = statusCode;
                  this.errors = errors;
                  this.isOperational = isOperational;

                  Error.captureStackTrace(this, this.constructor);
              }

                static badRequest(message = "Bad Request", errors?: unknown) {
                    return new ApiError(STATUS_CODES.BAD_REQUEST, message, errors);
                }

                static unauthorized(message = "Unauthorized") {
                    return new ApiError(STATUS_CODES.UNAUTHORIZED, message);
                }

                static forbidden(message = "Forbidden") {
                    return new ApiError(STATUS_CODES.FORBIDDEN, message);
                }

                static notFound(message = "Not Found") {
                    return new ApiError(STATUS_CODES.NOT_FOUND, message);
                }

                static conflict(message = "Conflict") {
                    return new ApiError(STATUS_CODES.CONFLICT, message);
                }

                static server(message = "Internal Server Error") {
                    return new ApiError(STATUS_CODES.INTERNAL_SERVER_ERROR, message);
                }
              }

              /*
              ? Usage:
              * throw new ApiError(404, "Not found");
              * throw ApiError.badRequest("Bad request");
              */

          - type: file
            name: api-response.ts
            content: |
              import { STATUS_CODES, StatusCode } from "../constants/status-codes";
              import type { Response } from "express";

              type ApiResponseParams<T> = {
                success: boolean;
                message: string;
                statusCode: StatusCode;
                data?: T | null;
                errors?: unknown;
              };

              export class ApiResponse<T = unknown> {
                public readonly success: boolean;
                public readonly message: string;
                public readonly statusCode: StatusCode;
                public readonly data?: T | null;
                public readonly errors?: unknown;

                constructor({
                  success,
                  message,
                  statusCode,
                  data = null,
                  errors,
                }: ApiResponseParams<T>) {
                  this.success = success;
                  this.message = message;
                  this.statusCode = statusCode;
                  this.data = data;
                  this.errors = errors;
                }

                send(res: Response): Response {
                  return res.status(this.statusCode).json({
                    success: this.success,
                    message: this.message,
                    statusCode: this.statusCode,
                    ...(this.data !== undefined && { data: this.data }),
                    ...(this.errors !== undefined && { errors: this.errors }),
                  });
                }

                static Success<T>(
                  res: Response,
                  message: string,
                  data?: T,
                  statusCode: StatusCode = STATUS_CODES.OK
                ): Response {
                  return new ApiResponse<T>({
                    success: true,
                    message,
                    data,
                    statusCode,
                  }).send(res);
                }

                static ok<T>(res: Response, message = "OK", data?: T) {
                  return ApiResponse.Success(res, message, data, STATUS_CODES.OK);
                }

                static created<T>(res: Response, message = "Created", data?: T) {
                  return ApiResponse.Success(res, message, data, STATUS_CODES.CREATED);
                }
              }

          - type: file
            name: jwt.ts
            content: |
              import jwt from "jsonwebtoken";
              import env from "../configs/env";

              const ACCESS_TOKEN_EXPIRY = "15m";
              const REFRESH_TOKEN_EXPIRY = "7d";

              // Generate a short-lived access token
              export function generateAccessToken(user: { _id: string }) {
                return jwt.sign(
                  { _id: user._id },
                  env.JWT_ACCESS_SECRET!,
                  { expiresIn: ACCESS_TOKEN_EXPIRY }
                );
              }

              // Generate a long-lived refresh token
              export function generateRefreshToken(userId: string) {
                return jwt.sign(
                  { userId },
                  env.JWT_REFRESH_SECRET!,
                  { expiresIn: REFRESH_TOKEN_EXPIRY }
                );
              }

              // Verify and decode an access token
              export function verifyAccessToken(token: string) {
                return jwt.verify(token, env.JWT_ACCESS_SECRET!) as {
                  _id: string;
                };
              }

              // Verify and decode a refresh token
              export function verifyRefreshToken(token: string) {
                return jwt.verify(token, env.JWT_REFRESH_SECRET!) as {
                  userId: string;
                };
              }

          - type: file
            name: logger.ts
            content: |
              import env from "../configs/env";
              import winston from "winston";
              import DailyRotateFile from "winston-daily-rotate-file";

              const { combine, timestamp, printf, colorize, errors } = winston.format;

              const logFormat = printf(({ level, message, timestamp, stack }) => {
                return `${timestamp} [${level}] : ${stack || message}`;
              });

              const transports: winston.transport[] = [];

              if (env.NODE_ENV !== "production") {
                transports.push(
                  new winston.transports.Console({
                    format: combine(
                      colorize(),
                      timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
                      errors({ stack: true }),
                      logFormat
                    ),
                  })
                );
              }

              if (env.NODE_ENV !== "development") {
                transports.push(
                  new DailyRotateFile({
                    dirname: "logs/app",
                    filename: "app-%DATE%.log",
                    datePattern: "YYYY-MM-DD",
                    zippedArchive: true,
                    maxSize: "20m",
                    maxFiles: "14d",
                    level: "info",
                  })
                );
                transports.push(
                  new DailyRotateFile({
                    dirname: "logs/error",
                    filename: "errors-%DATE%.log",
                    datePattern: "YYYY-MM-DD",
                    zippedArchive: true,
                    maxSize: "20m",
                    maxFiles: "30d",
                    level: "error",
                  })
                );
              }

              export const logger = winston.createLogger({
                level: env.LOG_LEVEL,
                format: combine(
                  timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
                  errors({ stack: true }),
                  logFormat
                ),
                transports,
                exitOnError: false,
              });

      - type: file
        name: app.ts
        content: |
          import express, { type Application } from "express";
          import "dotenv/config";
          import { errorHandler } from './middlewares/error-handler';

          import UserRouter from "./routes/user.routes"

          const app: Application = express();

          app.use(express.json());

          // routes here
          app.use('/api/v1/users', UserRouter);

          // Global error handler (should be after routes)
          app.use(errorHandler);

          export default app

  - type: file
    name: .env.example
    content: |
      PORT='3000'
      NODE_ENV='development'
      LOG_LEVEL='info'
      JWT_ACCESS_SECRET='your-access-secret'
      JWT_REFRESH_SECRET='your-refresh-secret'

feature_structure:
  - type: folder
    name: src
    children:
      - type: folder
        name: shared
        children:
          - type: folder
            name: configs
            children:
              - type: file
                name: env.ts
                content: |
                  interface Config {
                    PORT: number;
                    NODE_ENV: string;
                    LOG_LEVEL: string;
                    JWT_ACCESS_SECRET: string;
                    JWT_REFRESH_SECRET: string;
                  }

                  const env: Config = {
                    PORT: Number(process.env.PORT) || 3000,
                    NODE_ENV: process.env.NODE_ENV || 'development',
                    LOG_LEVEL: process.env.LOG_LEVEL || 'info',
                    JWT_REFRESH_SECRET: process.env.JWT_REFRESH_SECRET!,
                    JWT_ACCESS_SECRET: process.env.JWT_ACCESS_SECRET!
                  };

                  export default env;

          - type: folder
            name: constants
            children:
              - type: file
                name: status-codes.ts
                content: |
                  export const STATUS_CODES = {
                    // 2xx Success
                    OK: 200,
                    CREATED: 201,
                    ACCEPTED: 202,
                    NO_CONTENT: 204,

                    // 3xx Redirection
                    MOVED_PERMANENTLY: 301,
                    FOUND: 302,
                    NOT_MODIFIED: 304,

                    // 4xx Client Errors
                    BAD_REQUEST: 400,
                    UNAUTHORIZED: 401,
                    FORBIDDEN: 403,
                    NOT_FOUND: 404,
                    CONFLICT: 409,
                    UNPROCESSABLE_ENTITY: 422,
                    TOO_MANY_REQUESTS: 429,

                    // 5xx Server Errors
                    INTERNAL_SERVER_ERROR: 500,
                    NOT_IMPLEMENTED: 501,
                    BAD_GATEWAY: 502,
                    SERVICE_UNAVAILABLE: 503,
                    GATEWAY_TIMEOUT: 504,
                  } as const;

                  export type StatusCode = (typeof STATUS_CODES)[keyof typeof STATUS_CODES];

          - type: folder
            name: errors
            children:
              - type: file
                name: api-error.ts
                content: |
                  import { STATUS_CODES, StatusCode } from "../constants/status-codes";

                  export class ApiError extends Error {
                    public readonly statusCode: StatusCode;
                    public readonly isOperational: boolean;
                    public readonly errors?: unknown;

                    constructor(
                      statusCode: StatusCode,
                      message: string,
                      errors?: unknown,
                      isOperational = true
                    ) {
                      super(message);
                      this.name = "ApiError";
                      this.statusCode = statusCode;
                      this.errors = errors;
                      this.isOperational = isOperational;

                      Error.captureStackTrace(this, this.constructor);
                    }

                    static badRequest(message = "Bad Request", errors?: unknown) {
                      return new ApiError(STATUS_CODES.BAD_REQUEST, message, errors);
                    }

                    static unauthorized(message = "Unauthorized") {
                      return new ApiError(STATUS_CODES.UNAUTHORIZED, message);
                    }

                    static forbidden(message = "Forbidden") {
                      return new ApiError(STATUS_CODES.FORBIDDEN, message);
                    }

                    static notFound(message = "Not Found") {
                      return new ApiError(STATUS_CODES.NOT_FOUND, message);
                    }

                    static conflict(message = "Conflict") {
                      return new ApiError(STATUS_CODES.CONFLICT, message);
                    }

                    static server(message = "Internal Server Error") {
                      return new ApiError(STATUS_CODES.INTERNAL_SERVER_ERROR, message);
                    }
                  }

                  /*
                    ? Usage:
                    * throw new ApiError(404, "Not found");
                    * throw ApiError.badRequest("Bad request");
                  */

          - type: folder
            name: utils
            children:
              - type: file
                name: api-response.ts
                content: |
                  import { STATUS_CODES, StatusCode } from "../constants/status-codes";
                  import type { Response } from "express";

                  type ApiResponseParams<T> = {
                    success: boolean;
                    message: string;
                    statusCode: StatusCode;
                    data?: T | null;
                    errors?: unknown;
                  };

                  export class ApiResponse<T = unknown> {
                    public readonly success: boolean;
                    public readonly message: string;
                    public readonly statusCode: StatusCode;
                    public readonly data?: T | null;
                    public readonly errors?: unknown;

                    constructor({
                      success,
                      message,
                      statusCode,
                      data = null,
                      errors,
                    }: ApiResponseParams<T>) {
                      this.success = success;
                      this.message = message;
                      this.statusCode = statusCode;
                      this.data = data;
                      this.errors = errors;
                    }

                    send(res: Response): Response {
                      return res.status(this.statusCode).json({
                        success: this.success,
                        message: this.message,
                        statusCode: this.statusCode,
                        ...(this.data !== undefined && { data: this.data }),
                        ...(this.errors !== undefined && { errors: this.errors }),
                      });
                    }

                    static Success<T>(
                      res: Response,
                      message: string,
                      data?: T,
                      statusCode: StatusCode = STATUS_CODES.OK
                    ): Response {
                      return new ApiResponse<T>({
                        success: true,
                        message,
                        data,
                        statusCode,
                      }).send(res);
                    }

                    static ok<T>(res: Response, message = "OK", data?: T) {
                      return ApiResponse.Success(res, message, data, STATUS_CODES.OK);
                    }

                    static created<T>(res: Response, message = "Created", data?: T) {
                      return ApiResponse.Success(res, message, data, STATUS_CODES.CREATED);
                    }
                  }

              - type: file
                name: jwt.ts
                content: |
                  import jwt from "jsonwebtoken";
                  import env from "../configs/env";

                  const ACCESS_TOKEN_EXPIRY = "15m";
                  const REFRESH_TOKEN_EXPIRY = "7d";

                  // Generate a short-lived access token
                  export function generateAccessToken(user: { _id: string }) {
                    return jwt.sign(
                      { _id: user._id },
                      env.JWT_ACCESS_SECRET!,
                      { expiresIn: ACCESS_TOKEN_EXPIRY }
                    );
                  }

                  // Generate a long-lived refresh token
                  export function generateRefreshToken(userId: string) {
                    return jwt.sign(
                      { userId },
                      env.JWT_REFRESH_SECRET!,
                      { expiresIn: REFRESH_TOKEN_EXPIRY }
                    );
                  }

                  // Verify and decode an access token
                  export function verifyAccessToken(token: string) {
                    return jwt.verify(token, process.env.JWT_ACCESS_SECRET!) as {
                      _id: string;
                    };
                  }

                  // Verify and decode a refresh token
                  export function verifyRefreshToken(token: string) {
                    return jwt.verify(token, process.env.JWT_REFRESH_SECRET!) as {
                      userId: string;
                    };
                  }

              - type: file
                name: logger.ts
                content: |
                  import env from "../configs/env";
                  import winston from "winston";
                  import DailyRotateFile from "winston-daily-rotate-file";

                  const { combine, timestamp, printf, colorize, errors } = winston.format;

                  const logFormat = printf(({ level, message, timestamp, stack }) => {
                    return `${timestamp} [${level}] : ${stack || message}`;
                  });

                  const transports: winston.transport[] = [];

                  if (env.NODE_ENV !== "production") {
                    transports.push(
                      new winston.transports.Console({
                        format: combine(
                          colorize(),
                          timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
                          errors({ stack: true }),
                          logFormat
                        ),
                      })
                    );
                  }

                  if (env.NODE_ENV !== "development") {
                    transports.push(
                      new DailyRotateFile({
                        dirname: "logs/app",
                        filename: "app-%DATE%.log",
                        datePattern: "YYYY-MM-DD",
                        zippedArchive: true,
                        maxSize: "20m",
                        maxFiles: "14d",
                        level: "info",
                      })
                    );
                    transports.push(
                      new DailyRotateFile({
                        dirname: "logs/error",
                        filename: "errors-%DATE%.log",
                        datePattern: "YYYY-MM-DD",
                        zippedArchive: true,
                        maxSize: "20m",
                        maxFiles: "30d",
                        level: "error",
                      })
                    );
                  }

                  export const logger = winston.createLogger({
                    level: env.LOG_LEVEL,
                    format: combine(
                      timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
                      errors({ stack: true }),
                      logFormat
                    ),
                    transports,
                    exitOnError: false,
                  });

          - type: folder
            name: middlewares
            children:
              - type: file
                name: error-handler.ts
                content: |
                  import { Request, Response, NextFunction } from "express";
                  import env from "../configs/env";

                  import { ApiError } from "../errors/api-error";
                  import { logger } from "../utils/logger";

                  export const errorHandler = (
                    err: Error,
                    req: Request,
                    res: Response,
                    next: NextFunction
                  ) => {
                    let statusCode = 500;
                    let message = "Internal server error";

                    if (err instanceof ApiError) {
                      statusCode = err.statusCode;
                      message = err.message;
                    }

                    logger.error(
                      <Code children="Error: ${message} | Status: ${statusCode} | Path: ${req.method} ${req.originalUrl}" />,
                      err
                    );

                    const response = {
                      success: false,
                      message,
                      ...(env.NODE_ENV === "development" && { stack: err.stack }),
                    };

                    res.status(statusCode).json(response);
                  };

              - type: file
                name: verify-auth.ts
                content: |
                  import { NextFunction, Response } from "express";
                  import {
                    generateAccessToken,
                    generateRefreshToken,
                    verifyAccessToken,
                    verifyRefreshToken,
                  } from "../utils/jwt";
                  import { logger } from "../utils/logger";
                  import env from "../configs/env";
                  import { UserRequest } from "../../types/user";
                  import { ApiError } from "../errors/api-error";
                  import User from "../../modules/user/user.model";

                  const isProduction = env.NODE_ENV === "production";
                  const ACCESS_TOKEN_EXPIRY = 15 * 60 * 1000;
                  const REFRESH_TOKEN_EXPIRY = 7 * 24 * 60 * 60 * 1000;

                  export const COOKIE_OPTIONS = {
                    httpOnly: true,
                    secure: isProduction,
                    sameSite: isProduction ? ("none" as const) : ("lax" as const),
                    path: "/",
                  };

                  export async function verifyAuthentication(
                    req: UserRequest,
                    res: Response,
                    next: NextFunction
                  ): Promise<void> {
                    const accessToken = req.cookies?.accessToken;
                    const refreshToken = req.cookies?.refreshToken;

                    // Step 1: Try validating access token

                    try {
                      if (accessToken) {
                        const decoded = verifyAccessToken(accessToken);
                        req.user = decoded;
                        return next();
                      }
                    } catch (err) {
                      // Access token expired or invalid
                      logger.warn("Access token verification failed");
                      return next(ApiError.badRequest("Invalid or expired access token"));
                    }

                    // Step 2: Refresh token required if access token fails

                    if (!refreshToken) {
                      return next(ApiError.unauthorized("Unauthorized, Please login first."));
                    }

                    try {
                      const decodedRefresh = verifyRefreshToken(refreshToken);

                      // Step 3: Ensure user still exists

                      const userInDb = await User.findOne({
                        _id: decodedRefresh.userId,
                      });

                      if (!userInDb) {
                        return next(ApiError.unauthorized("Unauthorized, Please login first."));
                      }

                      // Step 4: Issue new tokens

                      const newAccessToken = generateAccessToken({
                        _id: userInDb._id.toString(),
                      });

                      const newRefreshToken = generateRefreshToken(decodedRefresh.userId);

                      // Step 5: Saved accessToken and refreshToken in cookie
                      res.cookie("accessToken", newAccessToken, {
                        ...COOKIE_OPTIONS,
                        maxAge: ACCESS_TOKEN_EXPIRY,
                      });

                      res.cookie("refreshToken", newRefreshToken, {
                        ...COOKIE_OPTIONS,
                        maxAge: REFRESH_TOKEN_EXPIRY,
                      });

                      // Step 6: Attach user to request

                      req.user = {
                        _id: decodedRefresh.userId,
                      };

                      // you can update the refresh token in the database here if you store it in the database

                      return next();
                    } catch (err: any) {
                      logger.warn("Refresh token verification failed");
                      return next(ApiError.unauthorized("Unauthorized, Please login first."));
                    }
                  }

      - type: folder
        name: modules
        children:
          - type: folder
            name: user
            children:
              - type: file
                name: user.routes.ts
                content: |
                  import { Response, Router } from "express";
                  import { UserRequest } from "../../types/user";
                  import { ApiResponse } from "../../shared/utils/api-response";
                  import { verifyAuthentication } from "../../shared/middlewares/verify-auth";

                  const router = Router();

                  router.get(
                    "/profile",
                    verifyAuthentication ,
                    (req:UserRequest, res:Response) => {
                      return ApiResponse.ok(res, "User profile", req.user);
                    }
                  );

                  export default router;

              - type: file
                name: user.model.ts
                content: |
                  import mongoose, { Document, Model, Schema } from "mongoose";

                  export interface IUser extends Document {
                    _id: mongoose.Types.ObjectId;
                    name: string;
                    email: string;
                    password: string;
                    role: "user" | "admin";
                    isEmailVerified: boolean;

                    createdAt: Date;
                    updatedAt: Date;
                  }

                  const userSchema = new Schema<IUser>(
                    {
                      name: {
                        type: String,
                        required: [true, "Name is required"],
                        trim: true,
                      },
                      email: {
                        type: String,
                        required: [true, "Email is required"],
                        unique: true,
                        lowercase: true,
                        trim: true,
                      },
                      password: {
                        type: String,
                        select: false,
                        default: null,
                      },
                      role: {
                        type: String,
                        enum: ["user", "admin"],
                        default: "user",
                      },
                      isEmailVerified: {
                        type: Boolean,
                        default: false,
                      },
                    },
                    {
                      timestamps: true,
                    }
                  );

                  const User: Model<IUser> = mongoose.model<IUser>("User", userSchema);
                  export default User;

      - type: folder
        name: routes
        children:
          - type: file
            name: index.ts
            content: |
              import { Router } from "express";
              import UserRouter from "../modules/user/user.routes";

              const router = Router();

              router.use("/v1/users", UserRouter);

              export default router;

      - type: file
        name: app.ts
        content: |
          import express, { type Application } from "express";
          import "dotenv/config";
          import { errorHandler } from './shared/middlewares/error-handler';
          import Routes from "./routes/index";

          const app: Application = express();

          app.use(express.json());

          // routes here
          app.use("/api", Routes);

          // Global error handler (should be after routes)
          app.use(errorHandler);

          export default app

      - type: file
        name: .env.example
        content: |
          PORT='3000'
          NODE_ENV='development'
          LOG_LEVEL='info'
          JWT_ACCESS_SECRET='your-access-secret'
          JWT_REFRESH_SECRET='your-refresh-secret'
---

# Verify Authentication Middleware

The <Code children='Verify Authentication Middleware' /> protects private routes by validating user authentication using **JWT access tokens and refresh tokens**.

It automatically:

- Verifies access tokens from cookies
- Refreshes expired access tokens using refresh tokens
- Re-attaches authenticated user data to the request
- Responds with standardized API errors when authentication fails

This middleware is designed for **secure, session-like authentication** in REST APIs.

## How Authentication Works

The middleware follows this sequence:

1. Read <Code children='accessToken' /> and <Code children='refreshToken' /> from cookies
2. If access token is valid ‚Üí allow request
3. If access token is expired:
   - Verify refresh token
   - Validate user existence
   - Issue new access & refresh tokens
   - Set new cookies automatically
4. If all checks fail ‚Üí reject the request

This ensures **seamless token rotation** without forcing the user to re-login.

## Installation Guide

This component requires additional ServerCN components.

**_üëâ Note:_** _You do not need to install any servercn dependencies manually. Installing this component will automatically install all required servercn dependencies. Manual installation is optional if you prefer to manage dependencies yourself._

### 1. Install ServerCN dependencies(Optional)

- **HTTP Status Codes:**
  <PackageManagerTabs command="npx servercn add http-status-codes" />

Documentation:
[HTTP Status Codes](/docs/components/http-status-codes)

- **Api Response Handler:**
  <PackageManagerTabs command="npx servercn add response-formatter" />

Documentation:
[Api Response Handler](/docs/components/response-formatter)

- **Api Error Handler:**
  <PackageManagerTabs command="npx servercn add error-handler" />

Documentation:
[Api Error Handler](/docs/components/error-handler)

- **JWT Authentication:**
  <PackageManagerTabs command="npx servercn add jwt-utils" />

Documentation:
[JWT Authentication](/docs/components/jwt-auth)

- **Logger:**
  <PackageManagerTabs command="npx servercn add logger" />

Documentation:
[Logger](/docs/components/logger)

### 2. Install this component

<PackageManagerTabs command="npx servercn add verify-auth-middleware" />

> ‚ö†Ô∏è If this dependency is not installed, the component will not function correctly.

## Prerequisites

Ensure the following environment variables are defined in **.env**:

```ts
PORT = "3000";
NODE_ENV = "development";
LOG_LEVEL = "info";
JWT_ACCESS_SECRET = "your-access-secret";
JWT_REFRESH_SECRET = "your-refresh-secret";
```

Ensure the following configuration are defined:

<Code children="src/configs/env.ts" />

```ts
interface Config {
  PORT: number;
  NODE_ENV: string;
  LOG_LEVEL: string;
  JWT_REFRESH_SECRET: string;
  JWT_ACCESS_SECRET: string;
}

const env: Config = {
  PORT: Number(process.env.PORT) || 3000,
  NODE_ENV: process.env.NODE_ENV || "development",
  LOG_LEVEL: process.env.LOG_LEVEL || "info",
  JWT_REFRESH_SECRET: process.env.JWT_ACCESS_SECRET!,
  JWT_ACCESS_SECRET: process.env.JWT_ACCESS_SECRET!
};

export default env;
```

To ensure the authentication middleware functions correctly, your project must define a User model with a structure similar to the following.

<Code children="src/models/user.model.ts" />

```ts
import mongoose, { Document, Model, Schema } from "mongoose";

export interface IUser extends Document {
  _id: mongoose.Types.ObjectId;
  name: string;
  email: string;
  password: string;
  role: "user" | "admin";
  isEmailVerified: boolean;

  createdAt: Date;
  updatedAt: Date;
}

const userSchema = new Schema<IUser>(
  {
    name: {
      type: String,
      required: [true, "Name is required"],
      trim: true
    },
    email: {
      type: String,
      required: [true, "Email is required"],
      unique: true,
      lowercase: true,
      trim: true
    },
    password: {
      type: String,
      select: false,
      default: null
    },
    role: {
      type: String,
      enum: ["user", "admin"],
      default: "user"
    },
    isEmailVerified: {
      type: Boolean,
      default: false
    }
  },
  {
    timestamps: true
  }
);

const User: Model<IUser> = mongoose.model<IUser>("User", userSchema);
export default User;
```

To access authenticated user data inside request handlers, define a custom request type.

<Code children="src/types/user.ts" />

```ts
import { Request } from "express";
import mongoose from "mongoose";

export interface UserRequest extends Request {
  user?: {
    _id?: string | mongoose.Types.ObjectId;
  };
}
```

## Basic Implementation

### 1. MVC Structure

<Code children="src/middlewares/verify-auth.ts" />

```ts
import { NextFunction, Request, Response } from "express";
import { generateAccessToken, generateRefreshToken, verifyAccessToken, verifyRefreshToken } from "../utils/jwt";
import { UserRequest } from "../types/user";
import { ApiError } from "../utils/api-error";
import { logger } from "../utils/logger";
import User from "../models/user.model";
import env from "../configs/env";

const isProduction = env.NODE_ENV === "production";
const ACCESS_TOKEN_EXPIRY = 15 * 60 * 1000;
const REFRESH_TOKEN_EXPIRY = 7 * 24 * 60 * 60 * 1000;

export const COOKIE_OPTIONS = {
  httpOnly: true,
  secure: isProduction,
  sameSite: isProduction ? ("none" as const) : ("lax" as const),
  path: "/"
};

export async function verifyAuthentication(req: UserRequest, res: Response, next: NextFunction): Promise<void> {
  const accessToken = req.cookies?.accessToken;
  const refreshToken = req.cookies?.refreshToken;

  // Step 1: Try validating access token

  try {
    if (accessToken) {
      const decoded = verifyAccessToken(accessToken);
      req.user = decoded;
      return next();
    }
  } catch (err) {
    // Access token expired or invalid
    logger.warn("Access token verification failed");
    return next(ApiError.badRequest("Invalid or expired access token"));
  }

  // Step 2: Refresh token required if access token fails

  if (!refreshToken) {
    return next(ApiError.unauthorized("Unauthorized, Please login first."));
  }

  try {
    const decodedRefresh = verifyRefreshToken(refreshToken);

    // Step 3: Ensure user still exists

    const userInDb = await User.findOne({
      _id: decodedRefresh.userId
    });

    if (!userInDb) {
      return next(ApiError.unauthorized("Unauthorized, Please login first."));
    }

    // Step 4: Issue new tokens

    const newAccessToken = generateAccessToken({
      _id: userInDb._id.toString()
    });

    const newRefreshToken = generateRefreshToken(decodedRefresh.userId);

    // Step 5: Saved accessToken and refreshToken in cookie
    res.cookie("accessToken", newAccessToken, {
      ...COOKIE_OPTIONS,
      maxAge: ACCESS_TOKEN_EXPIRY
    });

    res.cookie("refreshToken", newRefreshToken, {
      ...COOKIE_OPTIONS,
      maxAge: REFRESH_TOKEN_EXPIRY
    });

    // Step 6: Attach user to request

    req.user = {
      _id: decodedRefresh.userId
    };

    // you can update the refresh token in the database here if you store it in the database

    return next();
  } catch (err: any) {
    logger.warn("Refresh token verification failed");
    return next(ApiError.unauthorized("Unauthorized, Please login first."));
  }
}
```

### 2. Feature Structure

<Code children="src/shared/middlewares/verify-auth.ts" />

```ts
import { generateAccessToken, generateRefreshToken, verifyAccessToken, verifyRefreshToken } from "../utils/jwt";
import { logger } from "../utils/logger";
import env from "../configs/env";
import { UserRequest } from "../../types/user";
import { ApiError } from "../errors/api-error";
import User from "../../modules/user/user.model";
import { NextFunction, Response } from "express";

const isProduction = env.NODE_ENV === "production";
const ACCESS_TOKEN_EXPIRY = 15 * 60 * 1000;
const REFRESH_TOKEN_EXPIRY = 7 * 24 * 60 * 60 * 1000;

export const COOKIE_OPTIONS = {
  httpOnly: true,
  secure: isProduction,
  sameSite: isProduction ? ("none" as const) : ("lax" as const),
  path: "/"
};

export async function verifyAuthentication(req: UserRequest, res: Response, next: NextFunction): Promise<void> {
  const accessToken = req.cookies?.accessToken;
  const refreshToken = req.cookies?.refreshToken;

  // Step 1: Try validating access token

  try {
    if (accessToken) {
      const decoded = verifyAccessToken(accessToken);
      req.user = decoded;
      return next();
    }
  } catch (err) {
    // Access token expired or invalid
    logger.warn("Access token verification failed");
    return next(ApiError.badRequest("Invalid or expired access token"));
  }

  // Step 2: Refresh token required if access token fails

  if (!refreshToken) {
    return next(ApiError.unauthorized("Unauthorized, Please login first."));
  }

  try {
    const decodedRefresh = verifyRefreshToken(refreshToken);

    // Step 3: Ensure user still exists

    const userInDb = await User.findOne({
      _id: decodedRefresh.userId
    });

    if (!userInDb) {
      return next(ApiError.unauthorized("Unauthorized, Please login first."));
    }

    // Step 4: Issue new tokens

    const newAccessToken = generateAccessToken({
      _id: userInDb._id.toString()
    });

    const newRefreshToken = generateRefreshToken(decodedRefresh.userId);

    // Step 5: Saved accessToken and refreshToken in cookie
    res.cookie("accessToken", newAccessToken, {
      ...COOKIE_OPTIONS,
      maxAge: ACCESS_TOKEN_EXPIRY
    });

    res.cookie("refreshToken", newRefreshToken, {
      ...COOKIE_OPTIONS,
      maxAge: REFRESH_TOKEN_EXPIRY
    });

    // Step 6: Attach user to request

    req.user = {
      _id: decodedRefresh.userId
    };

    // you can update the refresh token in the database here if you store it in the database

    return next();
  } catch (err: any) {
    logger.warn("Refresh token verification failed");
    return next(ApiError.unauthorized("Unauthorized, Please login first."));
  }
}
```

## Usage Example

<Code children="src/routes/user.routes.ts" />

```ts
import { Router } from "express";
import { verifyAuthentication } from "../middlewares/verify-auth";

const router = Router();

router.get("/profile", verifyAuthentication, (req, res) => {
  return ApiResponse.ok(res, "User profile", req.user);
});

export default router;
```

## Error Responses

Authentication failures return standardized responses:

```json
{
  "success": false,
  "message": "Unauthorized, Please login first.",
  "statusCode": 401
}
```
