---
title: File Upload (Cloudinary & ImageKit)
description: The File Upload component provides a standardized way to handle file uploads in ServerCN using Cloudinary or ImageKit as the storage provider.

command: npx servercn-cli add file-upload

mvc_structure:
  - type: folder
    name: src
    children:
      - type: folder
        name: configs
        children:
          - type: file
            name: env.ts
            content: |
              interface Config {
                PORT: number;
                NODE_ENV: string;
                LOG_LEVEL: string;

                CLOUDINARY_CLOUD_NAME: string;
                CLOUDINARY_API_KEY: string;
                CLOUDINARY_API_SECRET: string;

                IMAGEKIT_PRIVATE_KEY: string;
              }

              const env: Config = {
                PORT: Number(process.env.PORT) || 3000,
                NODE_ENV: process.env.NODE_ENV || 'development',
                LOG_LEVEL: process.env.LOG_LEVEL || 'info',

                CLOUDINARY_CLOUD_NAME: process.env.CLOUDINARY_CLOUD_NAME!,
                CLOUDINARY_API_KEY: process.env.CLOUDINARY_API_KEY!,
                CLOUDINARY_API_SECRET: process.env.CLOUDINARY_API_SECRET!,

                IMAGEKIT_PRIVATE_KEY: process.env.IMAGEKIT_PRIVATE_KEY!
              };

              export default env;

          - type: file
            name: cloudinary.ts
            content: |
              // Cloudinary Configuration

              import { v2 as cloudinary } from "cloudinary";
              import env from "./env";

              cloudinary.config({
                cloud_name: env.CLOUDINARY_CLOUD_NAME,
                api_key: env.CLOUDINARY_API_KEY,
                api_secret: env.CLOUDINARY_API_SECRET,
              });

              export default cloudinary;

          - type: file
            name: imagekit.ts
            content: |
              // ImageKit Configuration

              import ImageKit from '@imagekit/nodejs';
              import env from './env';

              const imagekitClient = new ImageKit({
                privateKey: env.IMAGEKIT_PRIVATE_KEY,
              });

              export default imagekitClient;

      - type: folder
        name: constants
        children:
          - type: file
            name: status-codes.ts
            content: |
              export const STATUS_CODES = {
                // 2xx Success
                OK: 200,
                CREATED: 201,
                ACCEPTED: 202,
                NO_CONTENT: 204,

                // 3xx Redirection
                MOVED_PERMANENTLY: 301,
                FOUND: 302,
                NOT_MODIFIED: 304,

                // 4xx Client Errors
                BAD_REQUEST: 400,
                UNAUTHORIZED: 401,
                FORBIDDEN: 403,
                NOT_FOUND: 404,
                CONFLICT: 409,
                UNPROCESSABLE_ENTITY: 422,
                TOO_MANY_REQUESTS: 429,

                // 5xx Server Errors
                INTERNAL_SERVER_ERROR: 500,
                NOT_IMPLEMENTED: 501,
                BAD_GATEWAY: 502,
                SERVICE_UNAVAILABLE: 503,
                GATEWAY_TIMEOUT: 504,
              } as const;

              export type StatusCode = (typeof STATUS_CODES)[keyof typeof STATUS_CODES];

      - type: folder
        name: controllers
        children:
          - type: file
            name: upload.controller.ts
            content: |
              import { Request, Response, NextFunction } from "express";

              import {
                CloudinaryUploadResult,
                deleteFileFromCloudinary,
                uploadToCloudinary,
              } from "../services/cloudinary.service";

              import { ApiError } from "../utils/api-error";
              import { ApiResponse } from "../utils/api-response";
              import { AsyncHandler } from "../utils/async-handler";

              export const uploadFile = AsyncHandler(async (req: Request, res: Response, next: NextFunction) => {
                if (!req.file) {
                  return next(ApiError.badRequest("File is required"));
                }

                const file = await uploadToCloudinary(req.file.buffer, {
                  folder: "uploads/files",
                  resource_type: "auto",
                });

                return ApiResponse.created(res, "File uploaded successfully", file);
              });

              export const uploadMultipleFile = AsyncHandler(
                async (req: Request, res: Response, next: NextFunction) => {
                  const files = req.files as Express.Multer.File[];

                  if (!files || files.length === 0) {
                    return next(ApiError.badRequest("Files are required"));
                  }

                  const results: CloudinaryUploadResult[] = await Promise.all(
                    files.map(async (file) => {
                      return await uploadToCloudinary(file.buffer, {
                        folder: "uploads/images",
                      });
                    })
                  );

                  return ApiResponse.created(res, "Files uploaded successfully", results);
                }
              );

              export const deleteFile = AsyncHandler(async (req: Request, res: Response, next: NextFunction) => {
                const { public_id } = req.body;

                if (!public_id) {
                  return next(ApiError.badRequest("File ID is required"));
                }

                await deleteFileFromCloudinary([public_id]);

                return ApiResponse.Success(res, "File deleted successfully", null, 200);
              });

      - type: folder
        name: middlewares
        children:
          - type: file
            name: error-handler.ts
            content: |
              import { Request, Response, NextFunction } from "express";
              import env from "../configs/env";

              import { ApiError } from "../utils/api-error";
              import { logger } from "../utils/logger";
              import { STATUS_CODES } from "../constants/status-codes";

              export const errorHandler = (
                err: Error,
                req: Request,
                res: Response,
                next: NextFunction
              ) => {
                let statusCode = 500;
                let message = "Internal server error";

                if (err instanceof ApiError) {
                  statusCode = err.statusCode;
                  message = err.message;
                }

                logger.error(
                  err,
                 `Error: ${message} | Status: ${statusCode} | Path: ${req.method} ${req.originalUrl}`
                );

                const response = {
                  success: false,
                  message,
                  ...(env.NODE_ENV === "development" && { stack: err.stack }),
                };

                res.status(statusCode).json(response);
              };

          - type: file
            name: upload-file.ts
            content: |
              // multer configuration

              import multer from "multer";

              export const ALLOWED_FILE_TYPES = [
                "image/jpeg",
                "image/png",
                "image/webp",

                "video/mp4",
                "video/mpeg",
                "video/quicktime",

                "application/pdf",
              ];

              export const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

              const storage = multer.memoryStorage();

              const fileFilter: multer.Options["fileFilter"] = (_req, file, cb) => {
                if (!ALLOWED_FILE_TYPES.includes(file.mimetype)) {
                  return cb(null, false);
                }
                cb(null, true);
              };

              const upload = multer({
                storage,
                limits: { fileSize: MAX_FILE_SIZE },
                fileFilter,
              });

              export default upload;

      - type: folder
        name: routes
        children:
          - type: file
            name: upload.routes.ts
            content: |
              import { Router } from "express";

              import upload from "../middlewares/upload-file";
              import {
                deleteFile,
                uploadFile,
                uploadMultipleFile,
              } from "../controllers/upload.controller";

              const router = Router();

              router.post("/file", upload.single("file"), uploadFile);
              router.post("/files", upload.array("files", 10), uploadMultipleFile);
              router.delete("/", deleteFile);

              export default router;

      - type: folder
        name: services
        children:
          - type: file
            name: cloudinary.service.ts
            content: |
              import { DeleteApiResponse } from "cloudinary";
              import cloudinary from "../configs/cloudinary";

              export interface UploadOptions {
                folder: string;
                resource_type?: "image" | "video" | "raw" | "auto";
              }

              export interface CloudinaryUploadResult {
                url: string;
                public_id: string;
                size: number;
              }

              export const uploadToCloudinary = (
                buffer: Buffer,
                options: UploadOptions
              ): Promise<CloudinaryUploadResult> => {
                return new Promise((resolve, reject) => {
                  const stream = cloudinary.uploader.upload_stream(
                    {
                      folder: options.folder || "uploads",
                      resource_type: options.resource_type || "auto",
                    },
                    (error, result) => {
                      if (error || !result) {
                        return reject(error);
                      }
                      resolve({
                        url: result.secure_url,
                        public_id: result.public_id,
                        size: result.bytes,
                      });
                    }
                  );

                  stream.end(buffer);
                });
              };

              export const deleteFileFromCloudinary = (
                publicIds: string[]
              ): Promise<DeleteApiResponse> => {
                return new Promise((resolve, reject) => {
                  cloudinary.api.delete_resources(publicIds, (error, result) => {
                    if (error || !result) {
                      return reject(error);
                    }
                    resolve(result);
                  });
                });
              };

          - type: file
            name: imagekit.service.ts
            content: |
              import imagekitClient from "../configs/imagekit";
              import { toFile } from "@imagekit/nodejs";

              export interface UploadOptions {
                folder: string;
                fileName?: string;
              }

              export interface ImageKitUploadResult {
                url: string;
                fileId: string;
                size: number;
              }

              export const uploadToImageKit = async (
                buffer: Buffer,
                options: UploadOptions
              ): Promise<ImageKitUploadResult> => {
                try {
                  const fileName = options.fileName || `file-${Date.now()}`;
                  const file = await toFile(buffer, fileName);

                  const result = await imagekitClient.files.upload({
                    file: file,
                    fileName: fileName,
                    folder: options.folder || "uploads"
                  });

                  return {
                    url: result.url || "",
                    fileId: result.fileId || "",
                    size: result.size || 0
                  };
                } catch (error) {
                  throw error;
                }
              };

              export const deleteFileFromImageKit = async (
                fileIds: string[]
              ): Promise<void> => {
                try {
                  await Promise.all(
                    fileIds.map(fileId => imagekitClient.files.delete(fileId))
                  );
                } catch (error) {
                  throw error;
                }
              };

      - type: folder
        name: utils
        children:
          - type: file
            name: api-error.ts
            content: |
              import { STATUS_CODES, StatusCode } from "../constants/status-codes";

              export class ApiError extends Error {
              public readonly statusCode: StatusCode;
              public readonly isOperational: boolean;
              public readonly errors?: unknown;

              constructor(
                  statusCode: StatusCode,
                  message: string,
                  errors?: unknown,
                  isOperational = true
              ) {
                  super(message);
                  this.name = "ApiError";
                  this.statusCode = statusCode;
                  this.errors = errors;
                  this.isOperational = isOperational;

                  Error.captureStackTrace(this, this.constructor);
              }

              static badRequest(message = "Bad Request", errors?: unknown) {
                  return new ApiError(STATUS_CODES.BAD_REQUEST, message, errors);
              }

              static unauthorized(message = "Unauthorized") {
                  return new ApiError(STATUS_CODES.UNAUTHORIZED, message);
              }

              static forbidden(message = "Forbidden") {
                  return new ApiError(STATUS_CODES.FORBIDDEN, message);
              }

              static notFound(message = "Not Found") {
                  return new ApiError(STATUS_CODES.NOT_FOUND, message);
              }

              static conflict(message = "Conflict") {
                  return new ApiError(STATUS_CODES.CONFLICT, message);
              }

              static server(message = "Internal Server Error") {
                  return new ApiError(STATUS_CODES.INTERNAL_SERVER_ERROR, message);
              }
              }

              /*
              ? Usage:
              * throw new ApiError(404, "Not found");
              * throw ApiError.badRequest("Bad request");
              */

          - type: file
            name: api-response.ts
            content: |
              import { STATUS_CODES, StatusCode } from "../constants/status-codes";
              import type { Response } from "express";

              type ApiResponseParams<T> = {
                success: boolean;
                message: string;
                statusCode: StatusCode;
                data?: T | null;
                errors?: unknown;
              };

              export class ApiResponse<T = unknown> {
                public readonly success: boolean;
                public readonly message: string;
                public readonly statusCode: StatusCode;
                public readonly data?: T | null;
                public readonly errors?: unknown;

                constructor({
                  success,
                  message,
                  statusCode,
                  data = null,
                  errors,
                }: ApiResponseParams<T>) {
                  this.success = success;
                  this.message = message;
                  this.statusCode = statusCode;
                  this.data = data;
                  this.errors = errors;
                }

                send(res: Response): Response {
                  return res.status(this.statusCode).json({
                    success: this.success,
                    message: this.message,
                    statusCode: this.statusCode,
                    ...(this.data !== undefined && { data: this.data }),
                    ...(this.errors !== undefined && { errors: this.errors }),
                  });
                }

                static Success<T>(
                  res: Response,
                  message: string,
                  data?: T,
                  statusCode: StatusCode = 200
                ): Response {
                  return new ApiResponse<T>({
                    success: true,
                    message,
                    data,
                    statusCode,
                  }).send(res);
                }

                static ok<T>(res: Response, message = "OK", data?: T) {
                  return ApiResponse.Success(res, message, data, STATUS_CODES.OK);
                }

                static created<T>(res: Response, message = "Created", data?: T) {
                  return ApiResponse.Success(res, message, data, STATUS_CODES.CREATED);
                }
              }

              /*
              * Usage:
              * ApiResponse.ok(res, "OK", data);
              * ApiResponse.created(res, "Created", data);
              */

          - type: file
            name: async-handler.ts
            content: |
              import { Request, Response, NextFunction } from "express";

              export type AsyncRouteHandler = (
                req: Request,
                res: Response,
                next: NextFunction
              ) => Promise<unknown>;

              export function AsyncHandler(fn: AsyncRouteHandler) {
                return function (req: Request, res: Response, next: NextFunction) {
                  Promise.resolve(fn(req, res, next)).catch(next);
                };
              }

          - type: file
            name: logger.ts
            content: |
              import pino from "pino";
              import env from "../configs/env";

              const isProduction = env.NODE_ENV === "production";

              export const logger = pino({
                level: env.LOG_LEVEL || "info",

                base: {
                  pid: process.pid
                },

                timestamp: pino.stdTimeFunctions.isoTime,

                formatters: {
                  level(label) {
                    return { level: label };
                  }
                },

                redact: {
                  paths: [
                    "req.headers.authorization",
                    "req.headers.cookie",
                    "password",
                    "token",
                    "refreshToken"
                  ],
                  censor: "[REDACTED]"
                },

                ...(isProduction
                  ? {}
                  : {
                      transport: {
                        target: "pino-pretty",
                        options: {
                          colorize: true,
                          translateTime: "SYS:standard",
                          ignore: "pid,hostname"
                        }
                      }
                    })
              });

      - type: file
        name: app.ts
        content: |
          import express, { Application } from "express";
          import "dotenv/config";

          import { errorHandler } from "./middlewares/error-handler";
          import { logger } from "./utils/logger";

          import uploadRoutes from "./routes/upload.routes";
          import env from "./configs/env";

          const app: Application = express();

          const PORT = env.PORT;

          // middlewares
          app.use(express.urlencoded({ extended: true }));
          app.use(express.json());

          // routes
          app.use("/api/uploads", uploadRoutes);

          // Global error handler
          app.use(errorHandler);

          app.listen(PORT, () => {
            logger.info(`Server is running on http://localhost:${PORT}`);
          });

  - type: file
    name: .env.example
    content: |
      PORT="8000"
      NODE_ENV="development"
      LOG_LEVEL="info"

      # Cloudinary Configuration
      CLOUDINARY_CLOUD_NAME="your-cloud-name"
      CLOUDINARY_API_KEY="your-api-key"
      CLOUDINARY_API_SECRET="your-api-secret"

      # ImageKit Configuration
      IMAGEKIT_PRIVATE_KEY="your-imagekit-private-key"

  - type: file
    name: tsconfig.json
    content: |
      {
        "compilerOptions": {
          "target": "ES2021",
          "module": "es2022",
          "moduleResolution": "bundler",
          "strict": true,
          "esModuleInterop": true,
          "skipLibCheck": true,
          "outDir": "dist",
          "rootDir": "src"
        },
        "include": [ "src/**/*" ],
        "exclude": [ "node_modules" ]
      }

feature_structure:
  - type: folder
    name: src
    children:
      - type: folder
        name: shared
        children:
          - type: folder
            name: configs
            children:
              - type: file
                name: env.ts
                content: |
                  interface Config {
                    PORT: number;
                    NODE_ENV: string;
                    LOG_LEVEL: string;

                    CLOUDINARY_CLOUD_NAME: string;
                    CLOUDINARY_API_KEY: string;
                    CLOUDINARY_API_SECRET: string;

                    IMAGEKIT_PRIVATE_KEY: string;
                  }

                  const env: Config = {
                    PORT: Number(process.env.PORT) || 3000,
                    NODE_ENV: process.env.NODE_ENV || 'development',
                    LOG_LEVEL: process.env.LOG_LEVEL || 'info',

                    CLOUDINARY_CLOUD_NAME: process.env.CLOUDINARY_CLOUD_NAME!,
                    CLOUDINARY_API_KEY: process.env.CLOUDINARY_API_KEY!,
                    CLOUDINARY_API_SECRET: process.env.CLOUDINARY_API_SECRET!,

                    IMAGEKIT_PRIVATE_KEY: process.env.IMAGEKIT_PRIVATE_KEY!
                  };

                  export default env;

              - type: file
                name: cloudinary.ts
                content: |
                  // Cloudinary Configuration

                  import { v2 as cloudinary } from "cloudinary";
                  import env from "./env";

                  cloudinary.config({
                    cloud_name: env.CLOUDINARY_CLOUD_NAME,
                    api_key: env.CLOUDINARY_API_KEY,
                    api_secret: env.CLOUDINARY_API_SECRET,
                  });

                  export default cloudinary;

              - type: file
                name: imagekit.ts
                content: |
                  // ImageKit Configuration

                  import ImageKit from '@imagekit/nodejs';
                  import env from './env';

                  const imagekitClient = new ImageKit({
                    privateKey: env.IMAGEKIT_PRIVATE_KEY,
                  });

                  export default imagekitClient;

          - type: folder
            name: constants
            children:
              - type: file
                name: status-codes.ts
                content: |
                  export const STATUS_CODES = {
                    // 2xx Success
                    OK: 200,
                    CREATED: 201,
                    ACCEPTED: 202,
                    NO_CONTENT: 204,

                    // 3xx Redirection
                    MOVED_PERMANENTLY: 301,
                    FOUND: 302,
                    NOT_MODIFIED: 304,

                    // 4xx Client Errors
                    BAD_REQUEST: 400,
                    UNAUTHORIZED: 401,
                    FORBIDDEN: 403,
                    NOT_FOUND: 404,
                    CONFLICT: 409,
                    UNPROCESSABLE_ENTITY: 422,
                    TOO_MANY_REQUESTS: 429,

                    // 5xx Server Errors
                    INTERNAL_SERVER_ERROR: 500,
                    NOT_IMPLEMENTED: 501,
                    BAD_GATEWAY: 502,
                    SERVICE_UNAVAILABLE: 503,
                    GATEWAY_TIMEOUT: 504,
                  } as const;

                  export type StatusCode = (typeof STATUS_CODES)[keyof typeof STATUS_CODES];

          - type: folder
            name: errors
            children:
              - type: file
                name: api-error.ts
                content: |

                  import { STATUS_CODES, StatusCode } from "../constants/status-codes";

                  export class ApiError extends Error {
                  public readonly statusCode: StatusCode;
                  public readonly isOperational: boolean;
                  public readonly errors?: unknown;

                  constructor(
                      statusCode: StatusCode,
                      message: string,
                      errors?: unknown,
                      isOperational = true
                  ) {
                      super(message);
                      this.name = "ApiError";
                      this.statusCode = statusCode;
                      this.errors = errors;
                      this.isOperational = isOperational;

                      Error.captureStackTrace(this, this.constructor);
                  }

                  static badRequest(message = "Bad Request", errors?: unknown) {
                      return new ApiError(STATUS_CODES.BAD_REQUEST, message, errors);
                  }

                  static unauthorized(message = "Unauthorized") {
                      return new ApiError(STATUS_CODES.UNAUTHORIZED, message);
                  }

                  static forbidden(message = "Forbidden") {
                      return new ApiError(STATUS_CODES.FORBIDDEN, message);
                  }

                  static notFound(message = "Not Found") {
                      return new ApiError(STATUS_CODES.NOT_FOUND, message);
                  }

                  static conflict(message = "Conflict") {
                      return new ApiError(STATUS_CODES.CONFLICT, message);
                  }

                  static server(message = "Internal Server Error") {
                      return new ApiError(STATUS_CODES.INTERNAL_SERVER_ERROR, message);
                  }
                  }

                  /*
                  ? Usage:
                  * throw new ApiError(404, "Not found");
                  * throw ApiError.badRequest("Bad request");
                  */

          - type: folder
            name: utils
            children:
              - type: file
                name: api-response.ts
                content: |
                  import { STATUS_CODES, StatusCode } from "../constants/status-codes";
                  import type { Response } from "express";

                  type ApiResponseParams<T> = {
                    success: boolean;
                    message: string;
                    statusCode: StatusCode;
                    data?: T | null;
                    errors?: unknown;
                  };

                  export class ApiResponse<T = unknown> {
                    public readonly success: boolean;
                    public readonly message: string;
                    public readonly statusCode: StatusCode;
                    public readonly data?: T | null;
                    public readonly errors?: unknown;

                    constructor({
                      success,
                      message,
                      statusCode,
                      data = null,
                      errors,
                    }: ApiResponseParams<T>) {
                      this.success = success;
                      this.message = message;
                      this.statusCode = statusCode;
                      this.data = data;
                      this.errors = errors;
                    }

                    send(res: Response): Response {
                      return res.status(this.statusCode).json({
                        success: this.success,
                        message: this.message,
                        statusCode: this.statusCode,
                        ...(this.data !== undefined && { data: this.data }),
                        ...(this.errors !== undefined && { errors: this.errors }),
                      });
                    }

                    static Success<T>(
                      res: Response,
                      message: string,
                      data?: T,
                      statusCode: StatusCode = 200
                    ): Response {
                      return new ApiResponse<T>({
                        success: true,
                        message,
                        data,
                        statusCode,
                      }).send(res);
                    }

                    static ok<T>(res: Response, message = "OK", data?: T) {
                      return ApiResponse.Success(res, message, data, STATUS_CODES.OK);
                    }

                    static created<T>(res: Response, message = "Created", data?: T) {
                      return ApiResponse.Success(res, message, data, STATUS_CODES.CREATED);
                    }
                  }

                  /*
                  * Usage:
                  * ApiResponse.ok(res, "OK", data);
                  * ApiResponse.created(res, "Created", data);
                  */

              - type: file
                name: async-handler.ts
                content: |
                  import { Request, Response, NextFunction } from "express";

                  export type AsyncRouteHandler = (
                    req: Request,
                    res: Response,
                    next: NextFunction
                  ) => Promise<unknown>;

                  export function AsyncHandler(fn: AsyncRouteHandler) {
                    return function (req: Request, res: Response, next: NextFunction) {
                      Promise.resolve(fn(req, res, next)).catch(next);
                    };
                  }

              - type: file
                name: logger.ts
                content: |
                  import pino from "pino";
                  import  env  from "../configs/env";

                  export const logger = pino({
                    level: env.LOG_LEVEL,
                    transport:
                      env.NODE_ENV !== "production"
                        ? {
                            target: "pino-pretty",
                            options: {
                              colorize: true,
                              translateTime: "yyyy-mm-dd HH:MM:ss",
                              ignore: "pid,hostname",
                            },
                          }
                        : undefined,
                  });

          - type: folder
            name: middlewares
            children:
              - type: file
                name: error-handler.ts
                content: |
                  import { Request, Response, NextFunction } from "express";
                  import env from "../configs/env";

                  import { ApiError } from "../errors/api-error";
                  import { logger } from "../utils/logger";
                  import { STATUS_CODES } from "../constants/status-codes";

                  export const errorHandler = (
                    err: Error,
                    req: Request,
                    res: Response,
                    next: NextFunction
                  ) => {
                    let statusCode = 500;
                    let message = "Internal server error";

                    if (err instanceof ApiError) {
                      statusCode = err.statusCode;
                      message = err.message;
                    }

                    logger.error(
                      err,
                      `Error: ${message} | Status: ${statusCode} | Path: ${req.method} ${req.originalUrl}`
                    );

                    const response = {
                      success: false,
                      message,
                      ...(env.NODE_ENV === "development" && { stack: err.stack }),
                    };

                    res.status(statusCode).json(response);
                  };

              - type: file
                name: upload-file.ts
                content: |
                  // multer configuration

                  import multer from "multer";

                  export const ALLOWED_FILE_TYPES = [
                    "image/jpeg",
                    "image/png",
                    "image/webp",

                    "video/mp4",
                    "video/mpeg",
                    "video/quicktime",

                    "application/pdf",
                  ];

                  export const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

                  const storage = multer.memoryStorage();

                  const fileFilter: multer.Options["fileFilter"] = (_req, file, cb) => {
                    if (!ALLOWED_FILE_TYPES.includes(file.mimetype)) {
                      return cb(null, false);
                    }
                    cb(null, true);
                  };

                  const upload = multer({
                    storage,
                    limits: { fileSize: MAX_FILE_SIZE },
                    fileFilter,
                  });

                  export default upload;

      - type: folder
        name: modules
        children:
          - type: folder
            name: upload
            children:
              - type: file
                name: upload.controller.ts
                content: |
                  import { NextFunction, Request, Response } from "express";

                  import { ApiResponse } from "../../shared/utils/api-response";
                  import { AsyncHandler } from "../../shared/utils/async-handler";
                  import {
                    CloudinaryUploadResult,
                    deleteFileFromCloudinary,
                    uploadToCloudinary
                  } from "./upload.service";
                  import { ApiError } from "../../shared/errors/api-error";

                  export const uploadFile = AsyncHandler(
                    async (req: Request, res: Response, next: NextFunction) => {
                      if (!req.file) {
                        return next(ApiError.badRequest("File is required"));
                      }

                      const file = await uploadToCloudinary(req.file.buffer, {
                        folder: "uploads/files",
                        resource_type: "auto"
                      });

                      return ApiResponse.created(res, "File uploaded successfully", file);
                    }
                  );

                  export const uploadMultipleFile = AsyncHandler(
                    async (req: Request, res: Response, next: NextFunction) => {
                      const files = req.files as Express.Multer.File[];

                      if (!files || files.length === 0) {
                        return next(ApiError.badRequest("Files are required"));
                      }

                      const results: CloudinaryUploadResult[] = await Promise.all(
                        files.map(async file => {
                          return await uploadToCloudinary(file.buffer, {
                            folder: "uploads/images"
                          });
                        })
                      );

                      return ApiResponse.created(res, "Files uploaded successfully", results);
                    }
                  );

                  export const deleteFile = AsyncHandler(
                    async (req: Request, res: Response, next: NextFunction) => {
                      const { public_id } = req.body;

                      if (!public_id) {
                        return next(ApiError.badRequest("File ID is required"));
                      }

                      await deleteFileFromCloudinary([public_id]);

                      return ApiResponse.Success(res, "File deleted successfully", null, 200);
                    }
                  );

              - type: file
                name: upload.routes.ts
                content: |
                  import { Router } from "express";

                  import upload from "../../shared/middlewares/upload-file";
                  import {
                    deleteFile,
                    uploadFile,
                    uploadMultipleFile,
                  } from "./upload.controller";

                  const router = Router();

                  router.post("/file", upload.single("file"), uploadFile);
                  router.post("/files", upload.array("files", 10), uploadMultipleFile);
                  router.delete("/", deleteFile);

                  export default router;

              - type: file
                name: upload.service.ts
                content: |
                  import { DeleteApiResponse } from "cloudinary";
                  import cloudinary from "../../shared/configs/cloudinary";

                  export interface UploadOptions {
                    folder: string;
                    resource_type?: "image" | "video" | "raw" | "auto";
                  }

                  export interface CloudinaryUploadResult {
                    url: string;
                    public_id: string;
                    size: number;
                  }

                  export const uploadToCloudinary = (
                    buffer: Buffer,
                    options: UploadOptions
                  ): Promise<CloudinaryUploadResult> => {
                    return new Promise((resolve, reject) => {
                      const stream = cloudinary.uploader.upload_stream(
                        {
                          folder: options.folder || "uploads",
                          resource_type: options.resource_type || "auto",
                        },
                        (error, result) => {
                          if (error || !result) {
                            return reject(error);
                          }
                          resolve({
                            url: result.secure_url,
                            public_id: result.public_id,
                            size: result.bytes,
                          });
                        }
                      );

                      stream.end(buffer);
                    });
                  };

                  export const deleteFileFromCloudinary = (
                    publicIds: string[]
                  ): Promise<DeleteApiResponse> => {
                    return new Promise((resolve, reject) => {
                      cloudinary.api.delete_resources(publicIds, (error, result) => {
                        if (error || !result) {
                          return reject(error);
                        }
                        resolve(result);
                      });
                    });
                  }

              - type: file
                name: imagekit.service.ts
                content: |
                  import imagekitClient from "../../shared/configs/imagekit";
                  import { toFile } from "@imagekit/nodejs";

                  export interface UploadOptions {
                    folder: string;
                    fileName?: string;
                  }

                  export interface ImageKitUploadResult {
                    url: string;
                    fileId: string;
                    size: number;
                  }

                  export const uploadToImageKit = async (
                    buffer: Buffer,
                    options: UploadOptions
                  ): Promise<ImageKitUploadResult> => {
                    try {
                      const fileName = options.fileName || `file-${Date.now()}`;
                      const file = await toFile(buffer, fileName);

                      const result = await imagekitClient.files.upload({
                        file: file,
                        fileName: fileName,
                        folder: options.folder || "uploads"
                      });

                      return {
                        url: result.url || "",
                        fileId: result.fileId || "",
                        size: result.size || 0
                      };
                    } catch (error) {
                      throw error;
                    }
                  };

                  export const deleteFileFromImageKit = async (
                    fileIds: string[]
                  ): Promise<void> => {
                    try {
                      await Promise.all(
                        fileIds.map(fileId => imagekitClient.files.delete(fileId))
                      );
                    } catch (error) {
                      throw error;
                    }
                  };

      - type: folder
        name: routes
        children:
          - type: file
            name: index.ts
            content: |
              import { Router } from "express";
              import UploadRouter from "../modules/upload/upload.routes";

              const router = Router();

              router.use("/v1/uploads", UploadRouter);

              export default router;

      - type: file
        name: app.ts
        content: |
          import express, { type Application } from "express";
          import "dotenv/config";

          import { errorHandler } from './shared/middlewares/error-handler';
          import { logger } from "./shared/utils/logger";

          import Routes from "./routes/index";
          import env from "./shared/configs/env";

          const app: Application = express();

          const PORT = env.PORT;

          // middlewares
          app.use(express.urlencoded({ extended: true }));
          app.use(express.json());

          // routes here
          app.use("/api", Routes);

          // Global error handler (should be after routes)
          app.use(errorHandler);

          app.listen(PORT, () => {
            logger.info(`Server is running on http://localhost:${PORT}`);
          });

  - type: file
    name: .env.example
    content: |
      PORT="8000"
      NODE_ENV="development"
      LOG_LEVEL="info"

      # Cloudinary Configuration
      CLOUDINARY_CLOUD_NAME="your-cloud-name"
      CLOUDINARY_API_KEY="your-api-key"
      CLOUDINARY_API_SECRET="your-api-secret"

      # ImageKit Configuration
      IMAGEKIT_PRIVATE_KEY="your-imagekit-private-key"

  - type: file
    name: tsconfig.json
    content: |
      {
        "compilerOptions": {
          "target": "ES2021",
          "module": "es2022",
          "moduleResolution": "bundler",
          "strict": true,
          "esModuleInterop": true,
          "skipLibCheck": true,
          "outDir": "dist",
          "rootDir": "src"
        },
        "include": [ "src/**/*" ],
        "exclude": [ "node_modules" ]
      }
---

# File Upload (Cloudinary & ImageKit)

The **File Upload** component provides a standardized way to handle file uploads in ServerCN using **Cloudinary** or **ImageKit** as the storage provider.

It abstracts common concerns such as multipart handling, storage provider configuration, and secure uploads, while integrating cleanly with the rest of the ServerCN backend utilities.

## Features

- **Cloudinary** or **ImageKit** backed file storage
- Supports images, videos, and raw files
- Secure server-side uploads
- Express-compatible middleware
- Works seamlessly with <Code children='ApiError' />, <Code children='AsyncHandler' />, and middleware

## Installation Guide

This component requires additional ServerCN components.

**_ðŸ‘‰ Note:_** _You do not need to install any servercn dependencies manually. Installing this component will automatically install all required servercn dependencies. Manual installation is optional if you prefer to manage dependencies yourself._

### 1. Install ServerCN dependencies(Optional)

- **HTTP Status Codes:**

<PackageManagerTabs command="npx servercn-cli add http-status-codes" />

Documentation:
[HTTP Status Codes](/docs/components/http-status-codes)

- **Api Response Handler:**

<PackageManagerTabs command="npx servercn-cli add response-formatter" />

Documentation:
[Api Response Handler](/docs/components/response-formatter)

- **Api Error Handler:**

<PackageManagerTabs command="npx servercn-cli add error-handler" />

Documentation:
[Api Error Handler](/docs/components/error-handler)

- **Logger:**

<PackageManagerTabs command="npx servercn-cli add logger-pino" />

Documentation:
[Logger](/docs/components/logger)

- **Async Handler:**

<PackageManagerTabs command="npx servercn-cli add async-handler" />

Documentation:
[Async Handler](/docs/components/async-handler)

- **Global Error Handler:**

<PackageManagerTabs command="npx servercn-cli add global-error-handler" />

Documentation:
[Global Error Handler](/docs/components/global-error-handler)

### 2. Install this component

<PackageManagerTabs command="npx servercn-cli add file-upload" />

## Prerequisites

You must have either a **Cloudinary** or **ImageKit** account:

- **Cloudinary**: Click [here](https://cloudinary.com) if you don't have an account
- **ImageKit**: Click [here](https://imagekit.io) if you don't have an account

Define the following environment variables:

**For Cloudinary:**
```bash
PORT="8000"
NODE_ENV="development"
LOG_LEVEL="info"

# Cloudinary Configuration
CLOUDINARY_CLOUD_NAME="your-cloud-name"
CLOUDINARY_API_KEY="your-api-key"
CLOUDINARY_API_SECRET="your-api-secret"
```

**For ImageKit:**
```bash
PORT="8000"
NODE_ENV="development"
LOG_LEVEL="info"

# ImageKit Configuration
IMAGEKIT_PRIVATE_KEY="your-imagekit-private-key"
```

Ensure the following configuration are defined:

**MVC:** <Code children="src/configs/env.ts" />

**Feature:** <Code children="src/shared/configs/env.ts" />

**For Cloudinary:**
```ts
interface Config {
  PORT: number;
  NODE_ENV: string;
  LOG_LEVEL: string;

  CLOUDINARY_CLOUD_NAME: string;
  CLOUDINARY_API_KEY: string;
  CLOUDINARY_API_SECRET: string;
}

const env: Config = {
  PORT: Number(process.env.PORT) || 3000,
  NODE_ENV: process.env.NODE_ENV || "development",
  LOG_LEVEL: process.env.LOG_LEVEL || "info",

  CLOUDINARY_CLOUD_NAME: process.env.CLOUDINARY_CLOUD_NAME!,
  CLOUDINARY_API_KEY: process.env.CLOUDINARY_API_KEY!,
  CLOUDINARY_API_SECRET: process.env.CLOUDINARY_API_SECRET!
};

export default env;
```

**For ImageKit:**
```ts
interface Config {
  PORT: number;
  NODE_ENV: string;
  LOG_LEVEL: string;

  IMAGEKIT_PRIVATE_KEY: string;
}

const env: Config = {
  PORT: Number(process.env.PORT) || 3000,
  NODE_ENV: process.env.NODE_ENV || "development",
  LOG_LEVEL: process.env.LOG_LEVEL || "info",

  IMAGEKIT_PRIVATE_KEY: process.env.IMAGEKIT_PRIVATE_KEY!
};

export default env;
```

## Basic Implementation

### 1. Storage Provider Configuration

#### Cloudinary Configuration

Create a Cloudinary configuration file:

Create a Cloudinary configuration file:

**MVC:** <Code children="src/configs/cloudinary.ts" />

**Feature:** <Code children="src/shared/configs/cloudinary.ts" />

```ts
import { v2 as cloudinary } from "cloudinary";
import env from "./env";

cloudinary.config({
  cloud_name: env.CLOUDINARY_CLOUD_NAME,
  api_key: env.CLOUDINARY_API_KEY,
  api_secret: env.CLOUDINARY_API_SECRET
});

export default cloudinary;
```

#### ImageKit Configuration

Create an ImageKit configuration file:

**MVC:** <Code children="src/configs/imagekit.ts" />

**Feature:** <Code children="src/shared/configs/imagekit.ts" />

```ts
import ImageKit from '@imagekit/nodejs';
import env from './env';

const imagekitClient = new ImageKit({
  privateKey: env.IMAGEKIT_PRIVATE_KEY,
});

export default imagekitClient;
```

### 2. Upload Middleware

ServerCN uses **multer** to handle multipart file uploads.

**MVC:** <Code children="src/middlewares/upload-file.ts" />

**Feature:** <Code children="src/shared/middlewares/upload-file.ts" />

```ts
import multer from "multer";

export const ALLOWED_FILE_TYPES = [
  "image/jpeg",
  "image/png",
  "image/webp",
  "video/mp4",
  "video/mpeg",
  "video/quicktime",
  "application/pdf"
];

export const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

const storage = multer.memoryStorage();

const fileFilter: multer.Options["fileFilter"] = (_req, file, cb) => {
  if (!ALLOWED_FILE_TYPES.includes(file.mimetype)) {
    return cb(null, false);
  }
  cb(null, true);
};

const upload = multer({
  storage,
  limits: { fileSize: MAX_FILE_SIZE },
  fileFilter
});

export default upload;
```

### 3. Storage Provider Services

#### Cloudinary Services

Services for uploading files to Cloudinary and deleting files from Cloudinary.

**MVC:** <Code children="src/services/cloudinary.service.ts" /> or

<Code children="src/utils/cloudinary.ts" /> or
<Code children="src/helpers/cloudinary.ts" />

**Feature:** <Code children="src/modules/upload/upload.service.ts" /> (Cloudinary implementation)

```ts
import { DeleteApiResponse } from "cloudinary";
import cloudinary from "../configs/cloudinary.js";

export interface UploadOptions {
  folder: string;
  resource_type?: "image" | "video" | "raw" | "auto";
}

export interface CloudinaryUploadResult {
  url: string;
  public_id: string;
  size: number;
}

export const uploadToCloudinary = (
  buffer: Buffer,
  options: UploadOptions
): Promise<CloudinaryUploadResult> => {
  return new Promise((resolve, reject) => {
    const stream = cloudinary.uploader.upload_stream(
      {
        folder: options.folder || "uploads",
        resource_type: options.resource_type || "auto"
      },
      (error, result) => {
        if (error || !result) {
          return reject(error);
        }
        resolve({
          url: result.secure_url,
          public_id: result.public_id,
          size: result.bytes
        });
      }
    );

    stream.end(buffer);
  });
};

export const deleteFileFromCloudinary = (
  publicIds: string[]
): Promise<DeleteApiResponse> => {
  return new Promise((resolve, reject) => {
    cloudinary.api.delete_resources(publicIds, (error, result) => {
      if (error || !result) {
        return reject(error);
      }
      resolve(result);
    });
  });
};
```

#### ImageKit Services

Services for uploading files to ImageKit and deleting files from ImageKit.

**MVC:** <Code children="src/services/imagekit.service.ts" /> or

<Code children="src/utils/imagekit.ts" /> or
<Code children="src/helpers/imagekit.ts" />

**Feature:** <Code children="src/modules/upload/imagekit.service.ts" /> or

<Code children="src/modules/upload/upload.service.ts" /> (ImageKit implementation)

```ts
import imagekitClient from "../configs/imagekit";
import { toFile } from "@imagekit/nodejs";

export interface UploadOptions {
  folder: string;
  fileName?: string;
}

export interface ImageKitUploadResult {
  url: string;
  fileId: string;
  size: number;
}

export const uploadToImageKit = async (
  buffer: Buffer,
  options: UploadOptions
): Promise<ImageKitUploadResult> => {
  try {
    const fileName = options.fileName || `file-${Date.now()}`;
    const file = await toFile(buffer, fileName);

    const result = await imagekitClient.files.upload({
      file: file,
      fileName: fileName,
      folder: options.folder || "uploads"
    });

    return {
      url: result.url || "",
      fileId: result.fileId || "",
      size: result.size || 0
    };
  } catch (error) {
    throw error;
  }
};

export const deleteFileFromImageKit = async (
  fileIds: string[]
): Promise<void> => {
  try {
    await Promise.all(
      fileIds.map(fileId => imagekitClient.files.delete(fileId))
    );
  } catch (error) {
    throw error;
  }
};
```

## Usage Example

### 1. Setup controllers

#### Cloudinary Implementation

**MVC:** <Code children="src/controllers/upload.controller.ts" />

```ts
import { Request, Response, NextFunction } from "express";

import {
  CloudinaryUploadResult,
  deleteFileFromCloudinary,
  uploadToCloudinary
} from "../services/cloudinary.service";

import { ApiError } from "../utils/api-error";
import { ApiResponse } from "../utils/api-response";
import { AsyncHandler } from "../utils/async-handler";

export const uploadFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    if (!req.file) {
      return next(ApiError.badRequest("File is required"));
    }

    const file = await uploadToCloudinary(req.file.buffer, {
      folder: "uploads/files",
      resource_type: "auto"
    });

    return ApiResponse.created(res, "File uploaded successfully", file);
  }
);

export const uploadMultipleFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const files = req.files as Express.Multer.File[];

    if (!files || files.length === 0) {
      return next(ApiError.badRequest("Files are required"));
    }

    const results: CloudinaryUploadResult[] = await Promise.all(
      files.map(async file => {
        return await uploadToCloudinary(file.buffer, {
          folder: "uploads/images"
        });
      })
    );

    return ApiResponse.created(res, "Files uploaded successfully", results);
  }
);

export const deleteFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const { public_id } = req.body;

    if (!public_id) {
      return next(ApiError.badRequest("File ID is required"));
    }

    await deleteFileFromCloudinary([public_id]);

    return ApiResponse.Success(res, "File deleted successfully", null, 200);
  }
);
```

**Feature:** <Code children="src/modules/upload/upload.controller.ts" />

```ts
import { NextFunction, Request, Response } from "express";

import { ApiResponse } from "../../shared/utils/api-response";
import { AsyncHandler } from "../../shared/utils/async-handler";
import {
  CloudinaryUploadResult,
  deleteFileFromCloudinary,
  uploadToCloudinary
} from "./upload.service";
import { ApiError } from "../../shared/errors/api-error";

export const uploadFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    if (!req.file) {
      return next(ApiError.badRequest("File is required"));
    }

    const file = await uploadToCloudinary(req.file.buffer, {
      folder: "uploads/files",
      resource_type: "auto"
    });

    return ApiResponse.created(res, "File uploaded successfully", file);
  }
);

export const uploadMultipleFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const files = req.files as Express.Multer.File[];

    if (!files || files.length === 0) {
      return next(ApiError.badRequest("Files are required"));
    }

    const results: CloudinaryUploadResult[] = await Promise.all(
      files.map(async file => {
        return await uploadToCloudinary(file.buffer, {
          folder: "uploads/images"
        });
      })
    );

    return ApiResponse.created(res, "Files uploaded successfully", results);
  }
);

export const deleteFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const { public_id } = req.body;

    if (!public_id) {
      return next(ApiError.badRequest("File ID is required"));
    }

    await deleteFileFromCloudinary([public_id]);

    return ApiResponse.Success(res, "File deleted successfully", null, 200);
  }
);
```

#### ImageKit Implementation

**MVC:** <Code children="src/controllers/upload.controller.ts" />

```ts
import { Request, Response, NextFunction } from "express";

import {
  ImageKitUploadResult,
  deleteFileFromImageKit,
  uploadToImageKit
} from "../services/imagekit.service";

import { ApiError } from "../utils/api-error";
import { ApiResponse } from "../utils/api-response";
import { AsyncHandler } from "../utils/async-handler";

export const uploadFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    if (!req.file) {
      return next(ApiError.badRequest("File is required"));
    }

    const file = await uploadToImageKit(req.file.buffer, {
      folder: "uploads/files",
      fileName: req.file.originalname
    });

    return ApiResponse.created(res, "File uploaded successfully", file);
  }
);

export const uploadMultipleFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const files = req.files as Express.Multer.File[];

    if (!files || files.length === 0) {
      return next(ApiError.badRequest("Files are required"));
    }

    const results: ImageKitUploadResult[] = await Promise.all(
      files.map(async file => {
        return await uploadToImageKit(file.buffer, {
          folder: "uploads/images",
          fileName: file.originalname
        });
      })
    );

    return ApiResponse.created(res, "Files uploaded successfully", results);
  }
);

export const deleteFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const { fileIds }: { fileIds: string[] } = req.body;

    if (!fileIds || fileIds.length === 0) {
      return next(ApiError.badRequest("File IDs are required"));
    }

    await deleteFileFromImageKit(fileIds);

    return ApiResponse.Success(res, "File deleted successfully", null, 200);
  }
);
```

**Feature:** <Code children="src/modules/upload/upload.controller.ts" />

```ts
import { NextFunction, Request, Response } from "express";

import { ApiResponse } from "../../shared/utils/api-response";
import { AsyncHandler } from "../../shared/utils/async-handler";
import { ApiError } from "../../shared/errors/api-error";
import {
  deleteFileFromImageKit,
  ImageKitUploadResult,
  uploadToImageKit
} from "./upload.service";

export const uploadFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    if (!req.file) {
      return next(ApiError.badRequest("File is required"));
    }

    const file = await uploadToImageKit(req.file.buffer, {
      folder: "uploads/files",
      fileName: req.file.originalname
    });

    return ApiResponse.created(res, "File uploaded successfully", file);
  }
);

export const uploadMultipleFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const files = req.files as Express.Multer.File[];

    if (!files || files.length === 0) {
      return next(ApiError.badRequest("Files are required"));
    }

    const results: ImageKitUploadResult[] = await Promise.all(
      files.map(async file => {
        return await uploadToImageKit(file.buffer, {
          folder: "uploads/images",
          fileName: file.originalname
        });
      })
    );

    return ApiResponse.created(res, "Files uploaded successfully", results);
  }
);

export const deleteFile = AsyncHandler(
  async (req: Request, res: Response, next: NextFunction) => {
    const { fileIds }: { fileIds: string[] } = req.body;

    if (!fileIds || fileIds.length === 0) {
      return next(ApiError.badRequest("File IDs are required"));
    }

    await deleteFileFromImageKit(fileIds);

    return ApiResponse.Success(res, "File deleted successfully", null, 200);
  }
);
```

### 2. Setup routes

**MVC:** <Code children="src/routes/upload.routes.ts" />

```ts
import { Router } from "express";

import upload from "../middlewares/upload-file";
import {
  deleteFile,
  uploadFile,
  uploadMultipleFile
} from "../controllers/upload.controller";

const router = Router();

router.post("/file", upload.single("file"), uploadFile);
router.post("/files", upload.array("files", 10), uploadMultipleFile);
router.delete("/", deleteFile);

export default router;
```

**Feature:** <Code children="src/modules/upload/upload.routes.ts" />

```ts
import { Router } from "express";

import upload from "../../shared/middlewares/upload-file";
import {
  deleteFile,
  uploadFile,
  uploadMultipleFile
} from "./upload.controller";

const router = Router();

router.post("/file", upload.single("file"), uploadFile);
router.post("/files", upload.array("files", 10), uploadMultipleFile);
router.delete("/", deleteFile);

export default router;
```

<br />
<Code children="src/app.ts" />

```ts
import express, { Application } from "express";
import "dotenv/config";

import { errorHandler } from "./middlewares/error-handler";
import { logger } from "./utils/logger";

import uploadRoutes from "./routes/upload.routes";
import env from "./configs/env";

const app: Application = express();

const PORT = env.PORT;

// middlewares
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// routes
app.use("/api/uploads", uploadRoutes);

// Global error handler
app.use(errorHandler);

app.listen(PORT, () => {
  logger.info(`Server is running on http://localhost:${PORT}`);
});
```

## Security Best Practices

- Enforce file size limits
- Validate MIME types when required
- Use private folders for sensitive uploads
- Never expose storage provider secrets (Cloudinary API keys/secrets or ImageKit private keys) to the client
- Prefer authenticated routes for uploads
- Use environment variables for all sensitive configuration