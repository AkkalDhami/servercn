---
title: File Upload (Cloudinary)
description: The File Upload component provides a standardized way to handle file uploads in ServerCN using Cloudinary as the storage provider.

command: npx servercn add file-upload

mvc_structure:
  - type: folder
    name: src
    children:
      - type: folder
        name: configs
        children:
          - type: file
            name: env.ts
            content: |

              interface Config {
                PORT: number;
                NODE_ENV: string;
                LOG_LEVEL: string;

                CLOUDINARY_CLOUD_NAME: string;
                CLOUDINARY_API_KEY: string;
                CLOUDINARY_API_SECRET: string;
              }

              const env: Config = {
                PORT: Number(process.env.PORT) || 3000,
                NODE_ENV: process.env.NODE_ENV || 'development',
                LOG_LEVEL: process.env.LOG_LEVEL || 'info',

                CLOUDINARY_CLOUD_NAME: process.env.CLOUDINARY_CLOUD_NAME!,
                CLOUDINARY_API_KEY: process.env.CLOUDINARY_API_KEY!,
                CLOUDINARY_API_SECRET: process.env.CLOUDINARY_API_SECRET!
              };

              export default env;

          - type: file
            name: cloudinary.ts
            content: |
              // Cloudinary Configuration

              import { v2 as cloudinary } from "cloudinary";
              import env from "./env";

              cloudinary.config({
                cloud_name: env.CLOUDINARY_CLOUD_NAME,
                api_key: env.CLOUDINARY_API_KEY,
                api_secret: env.CLOUDINARY_API_SECRET,
              });

              export default cloudinary;

      - type: folder
        name: constants
        children:
          - type: file
            name: status-codes.ts
            content: |

              export const STATUS_CODES = {
              // 2xx Success
              OK: 200,
              CREATED: 201,
              ACCEPTED: 202,
              NO_CONTENT: 204,

              // 3xx Redirection
              MOVED_PERMANENTLY: 301,
              FOUND: 302,
              NOT_MODIFIED: 304,

              // 4xx Client Errors
              BAD_REQUEST: 400,
              UNAUTHORIZED: 401,
              FORBIDDEN: 403,
              NOT_FOUND: 404,
              CONFLICT: 409,
              UNPROCESSABLE_ENTITY: 422,
              TOO_MANY_REQUESTS: 429,

              // 5xx Server Errors
              INTERNAL_SERVER_ERROR: 500,
              NOT_IMPLEMENTED: 501,
              BAD_GATEWAY: 502,
              SERVICE_UNAVAILABLE: 503,
              GATEWAY_TIMEOUT: 504,
              } as const;

              export type StatusCode = (typeof STATUS_CODES)[keyof typeof STATUS_CODES];

      - type: folder
        name: controllers
        children:
          - type: file
            name: upload.controller.ts
            content: |

              import { Request, Response } from "express";

              import {
                CloudinaryUploadResult,
                deleteFileFromCloudinary,
                uploadToCloudinary,
              } from "../services/cloudinary.service";

              import { ApiError } from "../utils/api-error";
              import { ApiResponse } from "../utils/api-response";
              import { AsyncHandler } from "../utils/async-handler";

              export const uploadFile = AsyncHandler(async (req: Request, res: Response) => {
                if (!req.file) {
                  throw ApiError.badRequest("File is required");
                }

                const file = await uploadToCloudinary(req.file.buffer, {
                  folder: "uploads/files",
                  resource_type: "auto",
                });

                return ApiResponse.created(res, "File uploaded successfully", file);
              });

              export const uploadMultipleFile = AsyncHandler(
                async (req: Request, res: Response) => {
                  const files = req.files as Express.Multer.File[];

                  if (!files || files.length === 0) {
                    throw ApiError.badRequest("Files are required");
                  }

                  const results: CloudinaryUploadResult[] = await Promise.all(
                    files.map(async (file) => {
                      return await uploadToCloudinary(file.buffer, {
                        folder: "uploads/images",
                      });
                    })
                  );

                  return ApiResponse.created(res, "Files uploaded successfully", results);
                }
              );

              export const deleteFile = AsyncHandler(async (req: Request, res: Response) => {
                const { public_id } = req.body;

                if (!public_id) {
                  throw ApiError.badRequest("File ID is required");
                }

                await deleteFileFromCloudinary([public_id]);

                return ApiResponse.Success(res, "File deleted successfully", null, 200);
              });

      - type: folder
        name: middlewares
        children:
          - type: file
            name: error-handler.ts
            content: |

              import { Request, Response, NextFunction } from "express";
              import env from "../configs/env";

              import { ApiError } from "../utils/api-error";
              import { logger } from "../utils/logger";
              import { STATUS_CODES } from "../constants/status-codes";

              export const errorHandler = (
                err: Error,
                req: Request,
                res: Response,
                next: NextFunction
              ) => {
                let statusCode = 500;
                let message = "Internal server error";

                if (err instanceof ApiError) {
                  statusCode = err.statusCode;
                  message = err.message;
                }

                logger.error(
                  `Error: ${message} | Status: ${statusCode} | Path: ${req.method} ${req.originalUrl}`,
                  err
                );

                const response = {
                  success: false,
                  message,
                  ...(env.NODE_ENV === "development" && { stack: err.stack }),
                };

                res.status(statusCode).json(response);
              };

          - type: file
            name: upload-file.ts
            content: |
              // multer configuration

              import multer from "multer";

              export const ALLOWED_FILE_TYPES = [
                "image/jpeg",
                "image/png",
                "image/webp",

                "video/mp4",
                "video/mpeg",
                "video/quicktime",

                "application/pdf",
              ];

              export const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

              const storage = multer.memoryStorage();

              const fileFilter: multer.Options["fileFilter"] = (_req, file, cb) => {
                if (!ALLOWED_FILE_TYPES.includes(file.mimetype)) {
                  return cb(null, false);
                }
                cb(null, true);
              };

              const upload = multer({
                storage,
                limits: { fileSize: MAX_FILE_SIZE },
                fileFilter,
              });

              export default upload;

      - type: folder
        name: routes
        children:
          - type: file
            name: upload.routes.ts
            content: |

              import { Router } from "express";

              import upload from "../middlewares/upload-file";
              import {
                deleteFile,
                uploadFile,
                uploadMultipleFile,
              } from "../controllers/upload.controller";

              const router = Router();

              router.post("/file", upload.single("file"), uploadFile);
              router.post("/files", upload.array("files", 10), uploadMultipleFile);
              router.delete("/", deleteFile);

              export default router;

      - type: folder
        name: services
        children:
          - type: file
            name: cloudinary.service.ts
            content: |
              import { DeleteApiResponse } from "cloudinary";
              import cloudinary from "../configs/cloudinary";

              export interface UploadOptions {
                folder: string;
                resource_type?: "image" | "video" | "raw" | "auto";
              }

              export interface CloudinaryUploadResult {
                url: string;
                public_id: string;
                size: number;
              }

              export const uploadToCloudinary = (
                buffer: Buffer,
                options: UploadOptions
              ): Promise<CloudinaryUploadResult> => {
                return new Promise((resolve, reject) => {
                  const stream = cloudinary.uploader.upload_stream(
                    {
                      folder: options.folder || "uploads",
                      resource_type: options.resource_type || "auto",
                    },
                    (error, result) => {
                      if (error || !result) {
                        return reject(error);
                      }
                      resolve({
                        url: result.secure_url,
                        public_id: result.public_id,
                        size: result.bytes,
                      });
                    }
                  );

                  stream.end(buffer);
                });
              };

              export const deleteFileFromCloudinary = (
                publicIds: string[]
              ): Promise<DeleteApiResponse> => {
                return new Promise((resolve, reject) => {
                  cloudinary.api.delete_resources(publicIds, (error, result) => {
                    if (error || !result) {
                      return reject(error);
                    }
                    resolve(result);
                  });
                });
              };

      - type: folder
        name: utils
        children:
          - type: file
            name: api-error.ts
            content: |

              import { STATUS_CODES, StatusCode } from "../constants/status-codes";

              export class ApiError extends Error {
              public readonly statusCode: StatusCode;
              public readonly isOperational: boolean;
              public readonly errors?: unknown;

              constructor(
                  statusCode: StatusCode,
                  message: string,
                  errors?: unknown,
                  isOperational = true
              ) {
                  super(message);
                  this.name = "ApiError";
                  this.statusCode = statusCode;
                  this.errors = errors;
                  this.isOperational = isOperational;

                  Error.captureStackTrace(this, this.constructor);
              }

              static badRequest(message = "Bad Request", errors?: unknown) {
                  return new ApiError(STATUS_CODES.BAD_REQUEST, message, errors);
              }

              static unauthorized(message = "Unauthorized") {
                  return new ApiError(STATUS_CODES.UNAUTHORIZED, message);
              }

              static forbidden(message = "Forbidden") {
                  return new ApiError(STATUS_CODES.FORBIDDEN, message);
              }

              static notFound(message = "Not Found") {
                  return new ApiError(STATUS_CODES.NOT_FOUND, message);
              }

              static conflict(message = "Conflict") {
                  return new ApiError(STATUS_CODES.CONFLICT, message);
              }

              static server(message = "Internal Server Error") {
                  return new ApiError(STATUS_CODES.INTERNAL_SERVER_ERROR, message);
              }
              }

              /*
              ? Usage:
              * throw new ApiError(404, "Not found");
              * throw ApiError.badRequest("Bad request");
              */

          - type: file
            name: api-response.ts
            content: |

              import { STATUS_CODES, StatusCode } from "../constants/status-codes";
              import type { Response } from "express";

              type ApiResponseParams<T> = {
                success: boolean;
                message: string;
                statusCode: StatusCode;
                data?: T | null;
                errors?: unknown;
              };

              export class ApiResponse<T = unknown> {
                public readonly success: boolean;
                public readonly message: string;
                public readonly statusCode: StatusCode;
                public readonly data?: T | null;
                public readonly errors?: unknown;

                constructor({
                  success,
                  message,
                  statusCode,
                  data = null,
                  errors,
                }: ApiResponseParams<T>) {
                  this.success = success;
                  this.message = message;
                  this.statusCode = statusCode;
                  this.data = data;
                  this.errors = errors;
                }

                send(res: Response): Response {
                  return res.status(this.statusCode).json({
                    success: this.success,
                    message: this.message,
                    statusCode: this.statusCode,
                    ...(this.data !== undefined && { data: this.data }),
                    ...(this.errors !== undefined && { errors: this.errors }),
                  });
                }

                static Success<T>(
                  res: Response,
                  message: string,
                  data?: T,
                  statusCode: StatusCode = 200
                ): Response {
                  return new ApiResponse<T>({
                    success: true,
                    message,
                    data,
                    statusCode,
                  }).send(res);
                }

                static ok<T>(res: Response, message = "OK", data?: T) {
                  return ApiResponse.Success(res, message, data, STATUS_CODES.OK);
                }

                static created<T>(res: Response, message = "Created", data?: T) {
                  return ApiResponse.Success(res, message, data, STATUS_CODES.CREATED);
                }
              }

              /*
              * Usage:
              * ApiResponse.ok(res, "OK", data);
              * ApiResponse.created(res, "Created", data);
              */

          - type: file
            name: async-handler.ts
            content: |

              import { Request, Response, NextFunction } from "express";

              export type AsyncRouteHandler = (
                req: Request,
                res: Response,
                next: NextFunction
              ) => Promise<unknown>;

              export function AsyncHandler(fn: AsyncRouteHandler) {
                return function (req: Request, res: Response, next: NextFunction) {
                  Promise.resolve(fn(req, res, next)).catch(next);
                };
              }

          - type: file
            name: logger.ts
            content: |

              import env from "../configs/env";
              import winston from "winston";
              import DailyRotateFile from "winston-daily-rotate-file";

              const { combine, timestamp, printf, colorize, errors } = winston.format;

              const logFormat = printf(({ level, message, timestamp, stack }) => {
                return `${timestamp} [${level}] : ${stack || message}`;
              });

              const transports: winston.transport[] = [];

              if (env.NODE_ENV !== "production") {
                transports.push(
                  new winston.transports.Console({
                    format: combine(
                      colorize(),
                      timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
                      errors({ stack: true }),
                      logFormat
                    ),
                  })
                );
              }

              if (env.NODE_ENV !== "development") {
                transports.push(
                  new DailyRotateFile({
                    dirname: "logs/app",
                    filename: "app-%DATE%.log",
                    datePattern: "YYYY-MM-DD",
                    zippedArchive: true,
                    maxSize: "20m",
                    maxFiles: "14d",
                    level: "info",
                  })
                );
                transports.push(
                  new DailyRotateFile({
                    dirname: "logs/error",
                    filename: "errors-%DATE%.log",
                    datePattern: "YYYY-MM-DD",
                    zippedArchive: true,
                    maxSize: "20m",
                    maxFiles: "30d",
                    level: "error",
                  })
                );
              }

              export const logger = winston.createLogger({
                level: env.LOG_LEVEL,
                format: combine(
                  timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
                  errors({ stack: true }),
                  logFormat
                ),
                transports,
                exitOnError: false,
              });

      - type: file
        name: app.ts
        content: |
          import express, { Application } from "express";
          import "dotenv/config";

          import { errorHandler } from "./middlewares/error-handler";
          import { logger } from "./utils/logger";

          import uploadRoutes from "./routes/upload.routes";
          import env from "./configs/env";

          const app: Application = express();

          const PORT = env.PORT;

          // middlewares
          app.use(express.urlencoded({ extended: true }));
          app.use(express.json());

          // routes
          app.use("/api/uploads", uploadRoutes);

          // Global error handler
          app.use(errorHandler);

          app.listen(PORT, () => {
            logger.info(`Server is running on http://localhost:${PORT}`);
          });

      - type: file
        name: .env.example
        content: |
          PORT="8000"
          NODE_ENV="development"
          LOG_LEVEL="info"

          CLOUDINARY_CLOUD_NAME="your-cloud-name"
          CLOUDINARY_API_KEY="your-api-key"
          CLOUDINARY_API_SECRET="your-api-secret"

      - type: file
        name: tsconfig.json
        content: |
          {
            "compilerOptions": {
              "target": "ES2021",
              "module": "es2022",
              "moduleResolution": "bundler",
              "strict": true,
              "esModuleInterop": true,
              "skipLibCheck": true,
              "outDir": "dist",
              "rootDir": "src"
            },
            "include": [ "src/**/*" ],
            "exclude": [ "node_modules" ]
          }

feature_structure:
  - type: folder
    name: src
    children:
      - type: folder
        name: shared
        children:
          - type: folder
            name: configs
            children:
              - type: file
                name: env.ts
                content: |

                  interface Config {
                    PORT: number;
                    NODE_ENV: string;
                    LOG_LEVEL: string;

                    CLOUDINARY_CLOUD_NAME: string;
                    CLOUDINARY_API_KEY: string;
                    CLOUDINARY_API_SECRET: string;
                  }

                  const env: Config = {
                    PORT: Number(process.env.PORT) || 3000,
                    NODE_ENV: process.env.NODE_ENV || 'development',
                    LOG_LEVEL: process.env.LOG_LEVEL || 'info',

                    CLOUDINARY_CLOUD_NAME: process.env.CLOUDINARY_CLOUD_NAME!,
                    CLOUDINARY_API_KEY: process.env.CLOUDINARY_API_KEY!,
                    CLOUDINARY_API_SECRET: process.env.CLOUDINARY_API_SECRET!
                  };

                  export default env;

              - type: file
                name: cloudinary.ts
                content: |
                  // Cloudinary Configuration

                  import { v2 as cloudinary } from "cloudinary";
                  import env from "./env";

                  cloudinary.config({
                    cloud_name: env.CLOUDINARY_CLOUD_NAME,
                    api_key: env.CLOUDINARY_API_KEY,
                    api_secret: env.CLOUDINARY_API_SECRET,
                  });

                  export default cloudinary;

          - type: folder
            name: constants
            children:
              - type: file
                name: status-codes.ts
                content: |

                  export const STATUS_CODES = {
                  // 2xx Success
                  OK: 200,
                  CREATED: 201,
                  ACCEPTED: 202,
                  NO_CONTENT: 204,

                  // 3xx Redirection
                  MOVED_PERMANENTLY: 301,
                  FOUND: 302,
                  NOT_MODIFIED: 304,

                  // 4xx Client Errors
                  BAD_REQUEST: 400,
                  UNAUTHORIZED: 401,
                  FORBIDDEN: 403,
                  NOT_FOUND: 404,
                  CONFLICT: 409,
                  UNPROCESSABLE_ENTITY: 422,
                  TOO_MANY_REQUESTS: 429,

                  // 5xx Server Errors
                  INTERNAL_SERVER_ERROR: 500,
                  NOT_IMPLEMENTED: 501,
                  BAD_GATEWAY: 502,
                  SERVICE_UNAVAILABLE: 503,
                  GATEWAY_TIMEOUT: 504,
                  } as const;

                  export type StatusCode = (typeof STATUS_CODES)[keyof typeof STATUS_CODES];

          - type: folder
            name: errors
            children:
              - type: file
                name: api-error.ts
                content: |

                  import { STATUS_CODES, StatusCode } from "../constants/status-codes";

                  export class ApiError extends Error {
                  public readonly statusCode: StatusCode;
                  public readonly isOperational: boolean;
                  public readonly errors?: unknown;

                  constructor(
                      statusCode: StatusCode,
                      message: string,
                      errors?: unknown,
                      isOperational = true
                  ) {
                      super(message);
                      this.name = "ApiError";
                      this.statusCode = statusCode;
                      this.errors = errors;
                      this.isOperational = isOperational;

                      Error.captureStackTrace(this, this.constructor);
                  }

                  static badRequest(message = "Bad Request", errors?: unknown) {
                      return new ApiError(STATUS_CODES.BAD_REQUEST, message, errors);
                  }

                  static unauthorized(message = "Unauthorized") {
                      return new ApiError(STATUS_CODES.UNAUTHORIZED, message);
                  }

                  static forbidden(message = "Forbidden") {
                      return new ApiError(STATUS_CODES.FORBIDDEN, message);
                  }

                  static notFound(message = "Not Found") {
                      return new ApiError(STATUS_CODES.NOT_FOUND, message);
                  }

                  static conflict(message = "Conflict") {
                      return new ApiError(STATUS_CODES.CONFLICT, message);
                  }

                  static server(message = "Internal Server Error") {
                      return new ApiError(STATUS_CODES.INTERNAL_SERVER_ERROR, message);
                  }
                  }

                  /*
                  ? Usage:
                  * throw new ApiError(404, "Not found");
                  * throw ApiError.badRequest("Bad request");
                  */

          - type: folder
            name: utils
            children:
              - type: file
                name: api-response.ts
                content: |

                  import { STATUS_CODES, StatusCode } from "../constants/status-codes";
                  import type { Response } from "express";

                  type ApiResponseParams<T> = {
                    success: boolean;
                    message: string;
                    statusCode: StatusCode;
                    data?: T | null;
                    errors?: unknown;
                  };

                  export class ApiResponse<T = unknown> {
                    public readonly success: boolean;
                    public readonly message: string;
                    public readonly statusCode: StatusCode;
                    public readonly data?: T | null;
                    public readonly errors?: unknown;

                    constructor({
                      success,
                      message,
                      statusCode,
                      data = null,
                      errors,
                    }: ApiResponseParams<T>) {
                      this.success = success;
                      this.message = message;
                      this.statusCode = statusCode;
                      this.data = data;
                      this.errors = errors;
                    }

                    send(res: Response): Response {
                      return res.status(this.statusCode).json({
                        success: this.success,
                        message: this.message,
                        statusCode: this.statusCode,
                        ...(this.data !== undefined && { data: this.data }),
                        ...(this.errors !== undefined && { errors: this.errors }),
                      });
                    }

                    static Success<T>(
                      res: Response,
                      message: string,
                      data?: T,
                      statusCode: StatusCode = 200
                    ): Response {
                      return new ApiResponse<T>({
                        success: true,
                        message,
                        data,
                        statusCode,
                      }).send(res);
                    }

                    static ok<T>(res: Response, message = "OK", data?: T) {
                      return ApiResponse.Success(res, message, data, STATUS_CODES.OK);
                    }

                    static created<T>(res: Response, message = "Created", data?: T) {
                      return ApiResponse.Success(res, message, data, STATUS_CODES.CREATED);
                    }
                  }

                  /*
                  * Usage:
                  * ApiResponse.ok(res, "OK", data);
                  * ApiResponse.created(res, "Created", data);
                  */

              - type: file
                name: async-handler.ts
                content: |

                  import { Request, Response, NextFunction } from "express";

                  export type AsyncRouteHandler = (
                    req: Request,
                    res: Response,
                    next: NextFunction
                  ) => Promise<unknown>;

                  export function AsyncHandler(fn: AsyncRouteHandler) {
                    return function (req: Request, res: Response, next: NextFunction) {
                      Promise.resolve(fn(req, res, next)).catch(next);
                    };
                  }

              - type: file
                name: logger.ts
                content: |

                  import pino from "pino";
                  import  env  from "../configs/env";

                  export const logger = pino({
                    level: env.LOG_LEVEL,
                    transport:
                      env.NODE_ENV !== "production"
                        ? {
                            target: "pino-pretty",
                            options: {
                              colorize: true,
                              translateTime: "yyyy-mm-dd HH:MM:ss",
                              ignore: "pid,hostname",
                            },
                          }
                        : undefined,
                  });

          - type: folder
            name: middlewares
            children:
              - type: file
                name: error-handler.ts
                content: |

                  import { Request, Response, NextFunction } from "express";
                  import env from "../configs/env";

                  import { ApiError } from "../errors/api-error";
                  import { logger } from "../utils/logger";
                  import { STATUS_CODES } from "../constants/status-codes";

                  export const errorHandler = (
                    err: Error,
                    req: Request,
                    res: Response,
                    next: NextFunction
                  ) => {
                    let statusCode = 500;
                    let message = "Internal server error";

                    if (err instanceof ApiError) {
                      statusCode = err.statusCode;
                      message = err.message;
                    }

                    logger.error(
                      `Error: ${message} | Status: ${statusCode} | Path: ${req.method} ${req.originalUrl}`,
                      err
                    );

                    const response = {
                      success: false,
                      message,
                      ...(env.NODE_ENV === "development" && { stack: err.stack }),
                    };

                    res.status(statusCode).json(response);
                  };

              - type: file
                name: upload-file.ts
                content: |
                  // multer configuration

                  import multer from "multer";

                  export const ALLOWED_FILE_TYPES = [
                    "image/jpeg",
                    "image/png",
                    "image/webp",

                    "video/mp4",
                    "video/mpeg",
                    "video/quicktime",

                    "application/pdf",
                  ];

                  export const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

                  const storage = multer.memoryStorage();

                  const fileFilter: multer.Options["fileFilter"] = (_req, file, cb) => {
                    if (!ALLOWED_FILE_TYPES.includes(file.mimetype)) {
                      return cb(null, false);
                    }
                    cb(null, true);
                  };

                  const upload = multer({
                    storage,
                    limits: { fileSize: MAX_FILE_SIZE },
                    fileFilter,
                  });

                  export default upload;

      - type: folder
        name: modules
        children:
          - type: folder
            name: upload
            children:
              - type: file
                name: upload.controller.ts
                content: |

                  import { Request, Response } from "express";

                  import {
                    CloudinaryUploadResult,
                    deleteFileFromCloudinary,
                    uploadToCloudinary,
                  } from "./upload.service";

                  import { ApiError } from "../../shared/errors/api-error";
                  import { ApiResponse } from "../../shared/utils/api-response";
                  import { AsyncHandler } from "../../shared/utils/async-handler";

                  export const uploadFile = AsyncHandler(async (req: Request, res: Response) => {
                    if (!req.file) {
                      throw ApiError.badRequest("File is required");
                    }

                    const file = await uploadToCloudinary(req.file.buffer, {
                      folder: "uploads/files",
                      resource_type: "auto",
                    });

                    return ApiResponse.created(res, "File uploaded successfully", file);
                  });

                  export const uploadMultipleFile = AsyncHandler(
                    async (req: Request, res: Response) => {
                      const files = req.files as Express.Multer.File[];

                      if (!files || files.length === 0) {
                        throw ApiError.badRequest("Files are required");
                      }

                      const results: CloudinaryUploadResult[] = await Promise.all(
                        files.map(async (file) => {
                          return await uploadToCloudinary(file.buffer, {
                            folder: "uploads/images",
                          });
                        })
                      );

                      return ApiResponse.created(res, "Files uploaded successfully", results);
                    }
                  );

                  export const deleteFile = AsyncHandler(async (req: Request, res: Response) => {
                    const { public_id } = req.body;

                    if (!public_id) {
                      throw ApiError.badRequest("File ID is required");
                    }

                    await deleteFileFromCloudinary([public_id]);

                    return ApiResponse.Success(res, "File deleted successfully", null, 200);
                  });

              - type: file
                name: upload.routes.ts
                content: |

                  import { Router } from "express";

                  import upload from "../../shared/middlewares/upload-file";
                  import {
                    deleteFile,
                    uploadFile,
                    uploadMultipleFile,
                  } from "./upload.controller";

                  const router = Router();

                  router.post("/file", upload.single("file"), uploadFile);
                  router.post("/files", upload.array("files", 10), uploadMultipleFile);
                  router.delete("/", deleteFile);

                  export default router;

              - type: file
                name: upload.service.ts
                content: |

                  import { DeleteApiResponse } from "cloudinary";
                  import cloudinary from "../../shared/configs/cloudinary";

                  export interface UploadOptions {
                    folder: string;
                    resource_type?: "image" | "video" | "raw" | "auto";
                  }

                  export interface CloudinaryUploadResult {
                    url: string;
                    public_id: string;
                    size: number;
                  }

                  export const uploadToCloudinary = (
                    buffer: Buffer,
                    options: UploadOptions
                  ): Promise<CloudinaryUploadResult> => {
                    return new Promise((resolve, reject) => {
                      const stream = cloudinary.uploader.upload_stream(
                        {
                          folder: options.folder || "uploads",
                          resource_type: options.resource_type || "auto",
                        },
                        (error, result) => {
                          if (error || !result) {
                            return reject(error);
                          }
                          resolve({
                            url: result.secure_url,
                            public_id: result.public_id,
                            size: result.bytes,
                          });
                        }
                      );

                      stream.end(buffer);
                    });
                  };

                  export const deleteFileFromCloudinary = (
                    publicIds: string[]
                  ): Promise<DeleteApiResponse> => {
                    return new Promise((resolve, reject) => {
                      cloudinary.api.delete_resources(publicIds, (error, result) => {
                        if (error || !result) {
                          return reject(error);
                        }
                        resolve(result);
                      });
                    });
                  }

      - type: folder
        name: routes
        children:
          - type: file
            name: index.ts
            content: |
              import { Router } from "express";
              import UploadRouter from "../modules/upload/upload.routes";

              const router = Router();

              router.use("/v1/uploads", UploadRouter);

              export default router;

      - type: file
        name: app.ts
        content: |
          import express, { type Application } from "express";
          import "dotenv/config";

          import { errorHandler } from './shared/middlewares/error-handler';
          import { logger } from "./utils/logger";

          import Routes from "./routes/index";
          import env from "./shared/configs/env";

          const app: Application = express();

          const PORT = env.PORT;

          // middlewares
          app.use(express.urlencoded({ extended: true }));
          app.use(express.json());

          // routes here
          app.use("/api", Routes);

          // Global error handler (should be after routes)
          app.use(errorHandler);

          app.listen(PORT, () => {
            logger.info(`Server is running on http://localhost:${PORT}`);
          });

      - type: file
        name: .env.example
        content: |
          PORT="8000"
          NODE_ENV="development"
          LOG_LEVEL="info"

          CLOUDINARY_CLOUD_NAME="your-cloud-name"
          CLOUDINARY_API_KEY="your-api-key"
          CLOUDINARY_API_SECRET="your-api-secret"

      - type: file
        name: tsconfig.json
        content: |
          {
            "compilerOptions": {
              "target": "ES2021",
              "module": "es2022",
              "moduleResolution": "bundler",
              "strict": true,
              "esModuleInterop": true,
              "skipLibCheck": true,
              "outDir": "dist",
              "rootDir": "src"
            },
            "include": [ "src/**/*" ],
            "exclude": [ "node_modules" ]
          }
---

# File Upload (Cloudinary)

The **File Upload** component provides a standardized way to handle file uploads in ServerCN using **Cloudinary** as the storage provider.

It abstracts common concerns such as multipart handling, Cloudinary configuration, and secure uploads, while integrating cleanly with the rest of the ServerCN backend utilities.

## Features

- Cloudinary-backed file storage
- Supports images, videos, and raw files
- Secure server-side uploads
- Express-compatible middleware
- Works seamlessly with `ApiError`, `AsyncHandler`, and middleware

## Installation Guide

This component requires additional ServerCN components.

**_ðŸ‘‰ Note:_** _You do not need to install any dependencies manually. Installing this component will automatically install all required dependencies. Manual installation is optional if you prefer to manage dependencies yourself._

### 1. Install ServerCN dependencies(Optional)

- **HTTP Status Codes:**
  <PackageManagerTabs command="npx servercn add http-status-codes" />

Documentation:
[HTTP Status Codes](/docs/components/http-status-codes)

- **Api Response Handler:**
  <PackageManagerTabs command="npx servercn add response-formatter" />

Documentation:
[Api Response Handler](/docs/components/response-formatter)

- **Api Error Handler:**
  <PackageManagerTabs command="npx servercn add error-handler" />

Documentation:
[Api Error Handler](/docs/components/error-handler)

- **Logger:**
  <PackageManagerTabs command="npx servercn add logger" />

Documentation:
[Logger](/docs/components/logger)

- **Async Handler:**
  <PackageManagerTabs command="npx servercn add async-handler" />

Documentation:
[Async Handler](/docs/components/async-handler)

- **Global Error Handler:**
  <PackageManagerTabs command="npx servercn add global-error-handler" />

Documentation:
[Global Error Handler](/docs/components/global-error-handler)

### 2. Install this component

<PackageManagerTabs command="npx servercn add file-upload" />

## Prerequisites

You must have a Cloudinary account. Click [here](https://cloudinary.com) if you don't have.

Define the following environment variables:

```bash
PORT="8000"
NODE_ENV="development"
LOG_LEVEL="info"

CLOUDINARY_CLOUD_NAME="your-cloud-name"
CLOUDINARY_API_KEY="your-api-key"
CLOUDINARY_API_SECRET="your-api-secret"
```

Ensure the following configuration are defined:

`src/configs/env.ts`

```ts
interface Config {
  PORT: number;
  NODE_ENV: string;
  LOG_LEVEL: string;

  CLOUDINARY_CLOUD_NAME: string;
  CLOUDINARY_API_KEY: string;
  CLOUDINARY_API_SECRET: string;
}

const env: Config = {
  PORT: Number(process.env.PORT) || 3000,
  NODE_ENV: process.env.NODE_ENV || "development",
  LOG_LEVEL: process.env.LOG_LEVEL || "info",

  CLOUDINARY_CLOUD_NAME: process.env.CLOUDINARY_CLOUD_NAME!,
  CLOUDINARY_API_KEY: process.env.CLOUDINARY_API_KEY!,
  CLOUDINARY_API_SECRET: process.env.CLOUDINARY_API_SECRET!,
};

export default env;
```

## Basic Implementation

### 1. Cloudinary Configuration

Create a Cloudinary configuration file:

`src/configs/cloudinary.ts`

```ts
import { v2 as cloudinary } from "cloudinary";
import env from "./env";

cloudinary.config({
  cloud_name: env.CLOUDINARY_CLOUD_NAME,
  api_key: env.CLOUDINARY_API_KEY,
  api_secret: env.CLOUDINARY_API_SECRET,
});

export default cloudinary;
```

### 2. Upload Middleware

ServerCN uses **multer** to handle multipart file uploads.

`src/middlewares/upload-file.ts`

```ts
import multer from "multer";

export const ALLOWED_FILE_TYPES = [
  "image/jpeg",
  "image/png",
  "image/webp",

  "video/mp4",
  "video/mpeg",
  "video/quicktime",

  "application/pdf",
];

export const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB

const storage = multer.memoryStorage();

const fileFilter: multer.Options["fileFilter"] = (_req, file, cb) => {
  if (!ALLOWED_FILE_TYPES.includes(file.mimetype)) {
    return cb(null, false);
  }
  cb(null, true);
};

const upload = multer({
  storage,
  limits: { fileSize: MAX_FILE_SIZE },
  fileFilter,
});

export default upload;
```

### 3. Cloudinary Services

Services for uploading files to Cloudinary and delete files from cloudinary.

`src/services/cloudinary.service.ts` or `src/utils/cloudinary.ts` or `src/helpers/cloudinary.ts`

```ts
import { DeleteApiResponse } from "cloudinary";
import cloudinary from "../configs/cloudinary.js";

export interface UploadOptions {
  folder: string;
  resource_type?: "image" | "video" | "raw" | "auto";
}

export interface CloudinaryUploadResult {
  url: string;
  public_id: string;
  size: number;
}

export const uploadToCloudinary = (
  buffer: Buffer,
  options: UploadOptions,
): Promise<CloudinaryUploadResult> => {
  return new Promise((resolve, reject) => {
    const stream = cloudinary.uploader.upload_stream(
      {
        folder: options.folder || "uploads",
        resource_type: options.resource_type || "auto",
      },
      (error, result) => {
        if (error || !result) {
          return reject(error);
        }
        resolve({
          url: result.secure_url,
          public_id: result.public_id,
          size: result.bytes,
        });
      },
    );

    stream.end(buffer);
  });
};

export const deleteFileFromCloudinary = (
  publicIds: string[],
): Promise<DeleteApiResponse> => {
  return new Promise((resolve, reject) => {
    cloudinary.api.delete_resources(publicIds, (error, result) => {
      if (error || !result) {
        return reject(error);
      }
      resolve(result);
    });
  });
};
```

## Usage Example

`src/controllers/upload.controller.ts`

```ts
import { Request, Response } from "express";

import {
  CloudinaryUploadResult,
  deleteFileFromCloudinary,
  uploadToCloudinary,
} from "../services/cloudinary.service";

import { ApiError } from "../utils/api-error";
import { ApiResponse } from "../utils/api-response";
import { AsyncHandler } from "../utils/async-handler";

export const uploadFile = AsyncHandler(async (req: Request, res: Response) => {
  if (!req.file) {
    throw ApiError.badRequest("File is required");
  }

  const file = await uploadToCloudinary(req.file.buffer, {
    folder: "uploads/files",
    resource_type: "auto",
  });

  return ApiResponse.created(res, "File uploaded successfully", file);
});

export const uploadMultipleFile = AsyncHandler(
  async (req: Request, res: Response) => {
    const files = req.files as Express.Multer.File[];

    if (!files || files.length === 0) {
      throw ApiError.badRequest("Files are required");
    }

    const results: CloudinaryUploadResult[] = await Promise.all(
      files.map(async (file) => {
        return await uploadToCloudinary(file.buffer, {
          folder: "uploads/images",
        });
      }),
    );

    return ApiResponse.created(res, "Files uploaded successfully", results);
  },
);

export const deleteFile = AsyncHandler(async (req: Request, res: Response) => {
  const { public_id } = req.body;

  if (!public_id) {
    throw ApiError.badRequest("File ID is required");
  }

  await deleteFileFromCloudinary([public_id]);

  return ApiResponse.Success(res, "File deleted successfully", null, 200);
});
```

`src/routes/upload.routes.ts`

```ts
import { Router } from "express";

import upload from "../middlewares/upload-file";
import {
  deleteFile,
  uploadFile,
  uploadMultipleFile,
} from "../controllers/upload.controller";

const router = Router();

router.post("/file", upload.single("file"), uploadFile);
router.post("/files", upload.array("files", 10), uploadMultipleFile);
router.delete("/", deleteFile);

export default router;
```

`src/app.ts`

```ts
import express, { Application } from "express";
import "dotenv/config";

import { errorHandler } from "./middlewares/error-handler";
import { logger } from "./utils/logger";

import uploadRoutes from "./routes/upload.routes";
import env from "./configs/env";

const app: Application = express();

const PORT = env.PORT;

// middlewares
app.use(express.urlencoded({ extended: true }));
app.use(express.json());

// routes
app.use("/api/uploads", uploadRoutes);

// Global error handler
app.use(errorHandler);

app.listen(PORT, () => {
  logger.info(`Server is running on http://localhost:${PORT}`);
});
```

## Security Best Practices

- Enforce file size limits
- Validate MIME types when required
- Use private folders for sensitive uploads
- Never expose Cloudinary secrets to the client
- Prefer authenticated routes for uploads
